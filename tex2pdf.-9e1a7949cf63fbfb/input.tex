\documentclass[12pt,italian,]{book}

\usepackage[utf8]{inputenc} 
\usepackage{graphicx}
\usepackage{svg}
\usepackage{afterpage}
\usepackage{lmodern}
\usepackage{setspace}
\setstretch{1.3}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfauthor={menxit},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls


\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[shorthands=off,main=italian]{babel}
\else
  \usepackage{polyglossia}
  \setmainlanguage[]{italian}
\fi
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{3}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\author{menxit}
\date{}

\usepackage[
  top=5cm,
  bottom=5cm,
  left=4cm,
  right=4cm,
]{geometry}

\begin{document}


\newcommand{\frontespizio}{
   \thispagestyle{empty}
   \begin{center}
      \vspace{10mm}
      {\includegraphics[width=0.4 \linewidth]{template/uniroma3-logo}} \\
      \vspace{10mm}
      {\Large UNIVERSIT\`A DEGLI STUDI ROMA TRE} \\
      \vspace{5mm}
      {\LARGE {Facoltà di Ingegneria}} \\
      {\Large {Corso di Laurea in Ingegneria Informatica}} \\
      \vspace{15mm}
      {\LARGE Tesi Di Laurea} \\
      \vspace{15mm}
      {\LARGE {Analisi, progettazione e prove sperimentali di un FulgurHub in TypeScript}} \\
      \vspace{15mm}
      {\large Laureando \\  \textbf{{Federico Ginosa}} \\ Matricola {457026}} \\
      \vspace{7mm}

      \begin{tabular}{c  @{\hspace{2.5cm}} c}
        Relatore & Correlatore \\
        \textbf{{Alberto Paoluzzi}} & \textbf{{Federico Spini}} \\
      \end{tabular} \\

      \vfill
      {\large Anno Accademico {2017-2018}} \\
   \end{center}
   \newpage 
}
{
  \frontespizio
}

\newcommand{\generaDedica}{
   \thispagestyle{empty}
   \null\vspace{\stretch{1}}
   \begin{flushright}
      \emph{{{Ad Ada Lovelace}}}
   \end{flushright}
   \vspace{\stretch{2}}\null
}
{
\generaDedica
}

\chapter*{Ringraziamenti}
\small{
Grazie a tutti i professori che ho avuto il piacere di conoscere in questi ultimi 5 anni, in particolare il Professor Alberto Paoluzzi, Relatore di questa tesi.

Ridurre in parole i ringraziamenti che meriterebbe l'Ing. Federico Spini, Correlatore di questa tesi non è facile. Federico non si è limitato a guidarmi e consigliarmi, ma ha saputo trasmettermi l'importanza di un metodo educativo basato su un percorso di consapevolezza dialettico.

Ancora è difficile capacitarsi della fortuna avuta nell'incontrare una persona come Marco; ringrazio il mio Amico per avere reso così interessanti le ore di studio e per avermi mostrato la verità lapalissiana celata da una distribuzione di Poisson.

Zattera tra gli impervi mari della vita, questo per me sono sempre stati i miei genitori, che in queste righe ringrazio per non essersi mai stancati di indicarmi il nord.

Inoltre ringrazio tutti i miei compagni di studio, in particolare Alessio, Antonio, Claudia e Lorenzo grazie ai quali questo percorso è stato ancora più divertente.

E infine ringrazio Sara, che mi fa sentire importante anche se non conto niente.
}

\setcounter{tocdepth}{2}
\tableofcontents

\counterwithout{table}{chapter}
\listoftables

\counterwithout{figure}{chapter}
\listoffigures

\counterwithout{equation}{chapter}


\hypertarget{introduzione}{%
\chapter{Introduzione}\label{introduzione}}

\textbf{2008 whitepaper Bitcoin} Nel 2008 viene pubblicato il whitepaper di Bitcoin, una proposta di soluzione al problema della doppia spesa basata sull'utilizzo di una rete peer-to-peer {[}14{]}.

\textbf{\textbf{2009 pubblicazione protocollo}} Il 2009 vede la nascita della prima cryptovaluta, bitcoin, con la pubblicazione
dell'implementazione del protocollo Bitcoin. Gli standard variano, ma sembra
essersi formato un consenso nel riferirsi con Bitcoin maiuscolo al
protocollo e con bitcoin minuscolo alla moneta in se {[}4{]}.

\textbf{\textbf{Bitcoin 10 anni dopo}} Negli anni successivi decine di protocolli alternativi a Bitcoin sono fioriti. Le cryptovalute da argomento di nicchia hanno visto una costante crescita di adozione. Dal 2009 fino a oggi il numero di transazioni quotidiane è cresciuto più che linearmente, raggiungendo il suo attuale picco storico nel dicembre del 2017, con più di 450K transazioni in un giorno {[}2{]}.

\textbf{\textbf{Limiti architetturali}} Questo crescente interesse nei confronti delle cryptovalute si scontra però con i limiti architetturali relativi alla scalabilità della blockchain. Con gli attuali parametri di blocksize e blockinterval (1 megabyte e 10 minuti), il throughput massimo è compreso tra le 3 e le 7 tps (transazioni per secondo). Portando questi due parametri all'estremo, 1 megabyte e 1 minuto, si riuscirebbe a decuplicare il throughput, senza sacrificare il protocollo in termini di sicurezza {[}8{]}. Sebbene 30 - 70 tps rappresenterebbero un fondamentale miglioramento tecnologico di Bitcoin, il throughput raggiunto non sarebbe comunque confrontabile con quello di sistemi centralizzati analoghi come il circuito VISA, con le sue 56K tps {[}19{]}.

\textbf{\textbf{Soluzioni}} Diverse sono le soluzioni proposte per risolvere i problemi di scalabilità della blockchain e possono essere suddivise in tre categorie:

\begin{itemize}
\tightlist
\item
  \textbf{Algoritmo di consenso} Alla base del whitepaper di Satoshi Nakamoto c'è il Proof Of Work. Modificando il meccanismo alla base della ricerca del consenso è possibile migliorare la scalabilità della blockchain. Ad oggi diverse sono le alternative proposte {[}11{]}, {[}1{]}, {[}12{]}.
\item
  \textbf{Sharding} Questo concetto non è nuovo nel mondo dei database. L'idea è quella di suddividere la blockchain in più parti. La ricerca del consenso avviene in ciascuno di queste parti. Anche da questo punto di vista diversi sono i lavori e le proposte {[}13{]}, {[}5{]}.
\item
  \textbf{Off-chain} Layers è un famoso pattern architetturale. Un forte impiego di questo pattern è stato fatto nell'ambito del networking, vedi pila ISO/OSI. La scalabilità off-chain si realizza costruendo un secondo layer sopra alla blockchain, che permetta di ereditare le sue caratteristiche (sicurezza e distribuzione), aggiungendone delle altre, come la scalabilità.
\end{itemize}

Questi tre diversi approcci alla scalabilità della blockchain non sono in contrasto l'uno con l'altro, ma anzi possono essere applicati assieme in maniera sinergica. Nel lavoro di questa tesi ho approfondito l'ultima categoria, la scalabilità off-chain. In particolare mi sono occupato delle seguenti attività:

\begin{itemize}
\tightlist
\item
  Analisi dello stato dell'arte relativa a soluzioni di scalabilità off-chain
\item
  Realizzazione di un canale di pagamento inestinguibile (IPC)
\item
  Analisi, progettazione e sviluppo di FulgurHub
\item
  Prove sperimentali di FulgurHub
\end{itemize}

In questa tesi il Capitolo due tratta il background necessario, in particolare si approfondisce il design di un payment channel e si introduce l'architettura di FulgurHub. Nel terzo Capitolo si effettua l'analisi nel dettaglio di FulgurHub. Nel quarto Capitolo si descrivono le fasi di progettazione e sviluppo di FulgurHub. Nel quinto Capitolo si mostrano le prove sperimentali relative a quanto è stato implementato e si discutono i risultati in termini di performance e scalabilità.

\hypertarget{background}{%
\chapter{Background}\label{background}}

Questo Capitolo descrive il background necessario. In particolare in Sezione \ref{blockchain} si discute la blockchain: come funziona, i suoi casi d'uso e i suoi limiti. In Sezione \ref{state-channel} si descrivono gli state channel, facendo un affondo sui payment channel e sugli inextinguishable payment channel. Infine in Sezione \ref{fulgur-hub} si introduce il protocollo FulgurHub: le sue motivazione, le caratteristiche e i lavori correlati.

\hypertarget{blockchain}{%
\section{Blockchain}\label{blockchain}}

\textbf{\textbf{Il problema}} La blockchain risolve il problema del double spending in un sistema peer-to-peer completamente decentralizzato e trustless {[}14{]}. Questo permette di memorizzare in maniera immutabile dei pagamenti in un registro pubblico, avendo la certezza che nessuno possa spendere più volte lo stesso token. Letteralmente trustless significa "senza fiducia"; in questo contesto in realtà si intende che la fiducia viene spostata da un'entità centrale al protocollo.

\textbf{\textbf{Il caso d'uso}} Il caso d'uso tipico della blockchain è l'invio e la ricezione di pagamenti. La transazione rappresenta un pagamento. Essa può essere immaginata come un arco che unisce due nodi. Il nodo iniziale rappresenta il pagante, il nodo finale il pagato. Tutte queste transazioni vengono memorizzate su un registro pubblico detto ledger.

\textbf{\textbf{Pseudo-anonimato nella blockchain}} Bitcoin è pesudoanonimo. Le transazioni sono pubbliche, ma non sono direttamente accoppiate all'identità reale del pagante o del pagato, bensì ad uno loro pseudonimo (la chiave pubblica). Per migliorare la privacy, Satoshi Nakamato nel suo paper consiglia di utilizzare uno pseudonimo diverso per ogni singola transazione effettuata {[}14{]}. Questo accorgimento non basta però a rendere il sistema anonimo. Le informazioni sensibili rimangono in chiaro e pubbliche; se l'identità reale fosse mai associata alla chiave pubblica, tutte le precedenti transazioni effettuate da quest'ultimo verrebbero associate all'identità reale. Diverse soluzioni alternative a Bitcoin che migliorano la privacy degli utenti sono state proposte; Zcash è una di queste. Zcash si basa su zk-SNARKs (non-interactive zero-knowledge proof), uno zero-knowledge protocol. Una prova zero-knowledge permette a una parte di provare a l'altra che una condizione è vera, senza però rilevare i valori che rendono vera la condizione. Per esempio, dato un hash di un numero randomico, una parte può convincere l'altra del fatto che esiste un numero con questo hash, senza però rilevare quale sia il numero. Questa tipologia di protocollo permette a Zcash di memorizzare delle transazioni sul ledger pubblico, senza però rivelare le informazioni sensibili associate.

\textbf{\textbf{Cos'è la blockchain}} La blockchain è una lista concatenata di blocchi. Ciascun blocco contiene: l'hash del precedente blocco, il merkle root relativo alla lista di transazioni associate al blocco corrente e un nonce. In Bitcoin un nuovo blocco viene aggiunto ogni dieci minuti e il merkle root rappresenta una prova succinta di una lista di transazioni di dimensione minore o uguale a 1 megabyte.

\textbf{\textbf{Come funziona la PoW}} I blocchi vengono aggiunti dai miner. I miner sono dei nodi della rete che si occupano di trovare un nonce cha faccia si che l'hash del blocco corrente abbia un numero di zeri iniziali pari a \(D\). Questo valore \(D\) rappresenta la difficoltà corrente di mining della rete. La difficoltà è autoregolata dal protocollo e aumenta o diminuisce a seconda del tempo necessario per minare i precedenti blocchi. Un miner che riesce a presentare un nonce e un blocco valido ottiene in cambio le fee delle singole transazioni e una coinbase.

\textbf{\textbf{Cos'è uno smart contract}} Inviare un pagamento in Bitcoin significa sbloccare uno o più UTXO (Unspent Transaction Output). Sbloccare un UTXO significa presentare una prova crittografica della proprietà di un certo token. La verifica della prova crittografica viene effettuata da tutti i nodi della rete eseguendo un ASFND (automa a stati finiti non deterministico). Il protocollo Bitcoin permette di implementare e deployare sulla rete degli automi anche più complessi. Script è il linguaggio di programmazione stack-based non Turing-completo che permette di descrivere questi automi in Bitcoin. Quando la complessità degli automi aumenta, si parla di smart contract, ovvero di contratti che permettono lo sblocco di fondi previa verifica di un insieme complesso di regole.

\textbf{\textbf{Smart contract Turing-completi}} Sebbene abbia senso parlare di smart contract in Bitcoin, l'uso del termine in questo contesto è stato introdotto solo nel 2014, con la pubblicazione del whitepaper di Ethereum {[}6{]}. Ethereum è un protocollo che eredita gran parte delle caratteristiche di Bitcoin e in più introduce la EVM (Ethereum Virtual Machine) la macchina virtuale che esegue gli smart contract. Gli smart contract in Ethereum vengono descritti in Solidity, un linguaggio di programmazione C-like Turing-completo. La turing completezza permette di descrivere un più ampio spettro di regole. In questo senso uno smart contract ricorda il concetto di classe che si ritrova nei linguaggi di programmazione orientati agli oggetti e le operazione che è possibile eseguire i suoi metodi. Queste operazioni (come nei metodi) presentano dei parametri formali, ovvero gli input che l'utente può passare all'esecuzione di un'operazione. Come in altri linguaggi di programmazione orientati agli oggetti, anche negli smart contract esiste il concetto di visibilità delle operazioni. In Ethereum per esempio un metodo può essere:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{External}} Un metodo external può essere richiamato da un altro smart contract.
\item
  \textbf{\textbf{Public}} Permettono di definire l'interfaccia pubblica di uno smart contract; un metodo public può essere eseguito da un utente.
\item
  \textbf{\textbf{Internal}} Questa operazione può essere acceduta solo dallo smart contract corrente o da quelli che lo estendono. In Java un comportamento simile si ha con i metodi protect.
\item
  \textbf{\textbf{Private}} Questa operazione può essere acceduta solo dagli altri metodi dello smart contract correnti.
\end{itemize}

\textbf{\textbf{Scalabilità off-chain}} Nel Capitolo 1 sono stati introdotti i limiti architetturali della blockchain e le tre categorie di approcci risolutivi. La scalabilità off-chain è una delle tipologie di soluzioni atta a superare i limiti di scalabilità della blockchain. Questo approccio riduce sensibilmente le interazioni necessarie sulla blockchain, spostandole fuori di essa, senza compromettere le proprietà di sicurezza.

\hypertarget{state-channel}{%
\section{State channel}\label{state-channel}}

Gli state channel rappresentano un modo ampio e semplice di pensare a delle interazioni che potrebbero verificarsi sulla blockchain. Essi permettono a due parti di modificare in maniera sicura porzioni della blockchain, limitando al minimo le interazioni con la catena, ovvero la blockchain. Le componenti principali di uno state channel sono:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Deposito di stato on-chain}} Esso rappresenta la porzione di stato bloccata sulla catena mediante un indirizzo multisignature o uno smart contract. Questo deposito è bloccato in modo tale che un certo numero di partecipanti debba concordare un eventuale aggiornamento.
\item
  \textbf{\textbf{Deposito di stato off-chain}} Questa porzione di stato non è registrata sulla blockchain. Essa viene costruita sulla base dello scambio di messaggi off-chain firmati dalle parti. Ciascun aggiornamento del deposito di stato off-chain, invalida il precedente. Costruendo questi messaggi, essi potrebbero essere utilizzati sulla blockchain, sincronizzando stato on-chain e stato off-chain, ma per adesso vengono semplicemente trattenuti. Il costo di un aggiornamento di questo tipo è quello dello scambio di pochi messaggi su un protocollo come tcp o udp.
\end{itemize}

Quando uno dei due partecipanti dello state channel decide di rendere permanente la scrittura di un deposito di stato off-chain, l'ultimo stato cofirmato viene presentato in catena. Una parte disonesta potrebbe presentare in catena uno stato precedente all'ultimo; nel caso in cui questo avvenisse, la controparte può discutere l'aggiornamento in catena, provando che è stato presentato uno stato precedente all'ultimo. La prova consiste nel mostrare una proposta con numero di sequenza maggiore firmata dall'utente disonesto.

Come detto questi messaggi scambiati off-chain descrivono un aggiornamento di stato, per esempio la prossima mossa di una partita di tris o un pagamento {[}7{]}.

\hypertarget{payment-channel}{%
\subsection{Payment channel}\label{payment-channel}}

Un payment channel è una particolare tipologia di state channel. I messaggi scambiati off-chain rappresentano dei pagamenti, ovvero l'aggiornamento del bilancio delle parti. Instaurare un payment channel richiede una sola operazione on-chain da ciascuna parte. L'operazione on-chain viene eseguita su uno smart contract dedicato al singolo payment channel. Questa unica operazione on-chain abilita un numero potenzialmente illimitato di pagamenti off-chain; nella costruzione di seguito presentata la successione degli aggiornamenti di stato viene descritta da un intero senza segno a 256 bit; questo permette di scambiare un numero di aggiornamenti limitato a \(2^{256}\). I messaggi off-chain possono essere scambiati mediante qualunque mezzo, comunemente una connessione http. Un payment channel permette dunque di spostare i problemi di scalabilità dalla blockchain a un server http, ma la letteratura riguardo a come far scalare quest'ultimo è consolidata. I payment channel oltre a rappresentare una soluzione al problema della scalabilità, migliorano anche la confidenzialità della blockchain. Utilizzando un payment channel, le uniche transazioni visibili sul ledger pubblico sono quelle di apertura e di chiusura del canale; le transazioni off-chain intermedie invece, sono visibili esclusivamente agli utenti che partecipano al canale. Tuttavia questa caratteristica non preclude la possibilità a una delle due parti, di pubblicare i messaggi off-chain della parte avversaria, esponendo in questo modo informazioni sensibili.

\textbf{\textbf{Architettura}} L'architettura del payment channel di seguito descritta è quella utilizzata come base del lavoro svolto in questa tesi. Come detto in Sezione \ref{state-channel}, le componenti principali di uno state channel sono il deposito di stato off-chain e il deposito di stato on-chain. Nel contesto dei payment channel questi depositi descrivono lo stato attuale del bilancio delle due parti. In particolare il deposito di stato on-chain è memorizzato all'interno di uno smart contract deployato sulla blockchain di Ethereum, il deposito di stato off-chain invece viene memorizzato sulla macchina locale di entrambi gli utenti. Entrambi gli utenti mettono poi a disposizione un server http con degli endpoint pubblici. Questi endpoint pubblici permettono lo scambio dei messaggi off-chain, ovvero dei pagamenti.

\textbf{\textbf{Deploy}} Il deploy è la prima fase di inizializzazione. Alice deploya lo smart contract del relativo canale. L'operazione di deployment è richiesta per ciascun singolo payment channel. Questa fase permette di ottenere l'indirizzo di un smart contract, che nelle successive fasi verrà adottato per richiamare le operazioni on-chain che si intende richiamare; ad esempio l'invio di un aggiornamento del deposito di stato off-chain. In questa fase lo stato on-chain del payment channel è detto \(INIT\). Nella fase \(INIT\) lo smart contract permette di eseguire esclusivamente l'operazione di apertura del canale da parte di Alice.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/aa6199be656245d478c0d9acba3fb9c29703e124.png}
\caption{Deploy on-chain dello smart contract di un payment channel.}
\end{figure}

\textbf{\textbf{Apertura}} Alice apre il canale e blocca un quantitativo arbitrario di fondi all'interno dello smart contract. Questi fondi rappresentano il bilancio iniziale di Alice. Si fa notare come la fase di deploy e di apertura possano essere svolte con un'unica operazione, risparmiando in termini di transazioni on-chain. Oltre a depositare i fondi, Alice con questa operazione porta in catena il suo indirizzo ip e l'indirizzo ethereum di Berto. Terminata la procedura, lo stato on-chain del canale diventa \(OPENED\). Nello stato \(OPENED\), lo smart contract accetta esclusivamente l'esecuzione dell'operazione \(join\) da parte di Berto.

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/ed8a52fbe9fdea88dd1fcab62858ad63122f9ff1.png}
\caption{Apertura e deposito fondi on-chain in un payment channel.}
\end{figure}

\textbf{\textbf{Join}} In un secondo momento Berto effettua il join del canale di pagamento aperto da Alice; è possibile eseguire questa operazione solamente quando lo smart contract si trova nello stato \(OPENED\). Anche questa operazione viene effettuata on-chain. Berto deposita i fondi che corrisponderanno al suo bilancio iniziale e porta in catena il proprio indirizzo ip. Con questa operazione il canale è definitivamente stabilito e lo stato passa da \(OPENED\) a \(ESTABLISHED\). Da questo momento in poi lo smart contract accetta l'invio di messaggi che descrivono l'ultimo aggiornamento del deposito di stato off-chain.

\begin{figure}
\centering
\includegraphics[width=0.65\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/a4cc0ac63a116307832462e6854cb8cf140b1f8f.png}
\caption{Join e deposito fondi on-chain in un payment channel.}
\end{figure}

\textbf{\textbf{Schema propose/accept}} I pagamenti off-chain avvengono mediante lo schema propose/accept. Alice (o Berto) propone un aggiornamento dello stato del canale firmando un messaggio. Nell'ambito dello schema propose/accept gli aggiornamenti di stato off-chain prendono il nome di proposta. La proposta viene firmata e inviata da Alice. Berto riceve la proposta, ne verifica la validità ed eventualmente l'accetta rispondendo con la proposta controfirmata. A questo punto è possibile considerare il pagamento come confermato, senza la necessità di ulteriori tempi di attesa. Sebbene l'aggiornamento di stato non sia ancora stato portato in catena, una proposta cofirmata rappresenta per entrambi le parti una prova inconfutabile di avvenuto pagamento.

\textbf{\textbf{Gli endpoint pubblici}} Nello schema propose/accept ciascuna controparte di un payment channel mette a disposizione un server http. Gli endpoint pubblici sono detti /propose e /accept. L'endpoint /propose permette di ricevere una proposta di aggiornamento di bilancio. L'endpoint /accept permette di ricevere una proposta precedentemente inviata. In in Tabella \protect\hyperlink{struct_propose}{1} si presenta la struttura di una proposta.

\textbf{\textbf{Richiesta di chiusura}} Chiudere un canale significa aggiornare il bilancio on-chain delle parti in modo tale che corrisponda a quello dell'ultima proposta comunemente accordata. Con proposta comunemente accordata si intende un aggiornamento di stato firmato da entrambe le parti. La prima fase di questo processo è detta richiesta di chiusura. In particolare si porta in catena l'ultima proposta comunemente firmata. In questo modo lo stato del canale passa da \(ESTABLISHED\) a \(CLOSED\). La richiesta di chiusura può essere effettuata da Alice o da Berto.

\begin{longtable}[]{@{}ll@{}}
\caption{\protect\hypertarget{struct_propose}{}{}Struttura di una proposta}\tabularnewline
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endfirsthead
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endhead
seq & Il numero di sequenza\tabularnewline
balance\textsubscript{a} & Il balance di chi ha aperto il canale\tabularnewline
balance\textsubscript{b} & Il balance di chi ha effettuato il join del canale\tabularnewline
sign & La firma della propose\tabularnewline
\bottomrule
\end{longtable}

\textbf{\textbf{Finalizzazione della chiusura}} L'operazione di finalizzazione della chiusura viene effettuata da tutte e due le parti. Essa corrisponde al ritiro on-chain dei rispettivi fondi. Questa operazione può essere effettuata solo quando è passato un certo tempo dalla richiesta di chiusura. Il tempo che occorre attendere per finalizzare la chiusura è detto grace period (tempo di grazia).

\textbf{\textbf{Discutere una proposta}} Alice (o Berto) potrebbe non comportarsi correttamente, portando in chiusura una proposta diversa dalla più recente. In questo caso Berto può discutere la proposta durante il grace period. Discutere significa portare in catena una proposta firmata da Alice con numero di sequenza maggiore rispetto a quella presentata (vedi Tabella \protect\hyperlink{struct_propose}{1}). Nel caso in cui la discussione abbia successo, Alice viene punita; la punizione consiste nel trasferimento di tutti i suoi fondi a Berto.

\textbf{\textbf{Il problema della free-option}} Quando Alice invia una proposta a Berto senza ricevere la controfirma, Berto ha il vantaggio di poter scegliere di chiudere il canale con due proposta, la penultima o l'ultima. Inviare una proposta però coincide con inviare un pagamento, quindi sebbene Berto possa decidere di presentare in catena la penultima proposta, questa descriverà uno stato per lui più svantaggioso.

\hypertarget{inextinguishable-payment-channel}{%
\subsection{Inextinguishable payment channel}\label{inextinguishable-payment-channel}}

I payment channel permettono di trasferire un volume di coin limitato. Il valore trasferibile è fissato alla somma del bilancio di Alice e di Berto. Spesso questi canali sono sbilanciati, ovvero una delle due controparti effettua più pagamenti dell'altra (si pensi a un canale di pagamento instaurato tra il proprietario di un ecommerce e un suo utente). Un canale sbilanciato nel tempo prosciuga il balance di una delle due parti, rendendo il payment channel inutilizzabile. Il canale diventa inutilizzabile poiché una delle due parti ha un bilancio pari a zero e quindi non può più effettuare dei pagamenti. Nella tipologia di canale di pagamento presentata in Sezione \ref{payment-channel}, l'unica soluzione a questo problema consiste nel chiudere il payment channel corrente e aprirne un nuovo, caricando i nuovi fondi. Questa soluzione però richiede delle onerose operazioni on-chain; in particolare occorre effettuare il deploy di un nuovo smart contract e successivamente instaurare la connessione con le operazioni di apertura e di join. Gli inextinguishable payment channel (o IPC) superano questo problema, proponendo dei canali di pagamento che permettono di ricaricare o prelevare un'entità \(N\) di coin a caldo dal proprio bilancio, evitando quindi di dover stabilire un nuovo canale di pagamento. Questo permette di instaurare dei canali che possono rimanere aperti per un tempo indefinitamente lungo; infatti quando il bilancio di una delle due parti si prosciuga, quest'ultima potrà decidere di ricaricare a caldo un certo quantitativo di coin con una singola operazione on-chain. Se invece una delle due parti decide di voler spostare i fondi off-chain sulla catena, potrà farlo con un prelievo a caldo, evitando di dover chiudere il canale.

\textbf{\textbf{Schema detach/attach}} Questo protocollo rappresenta un'estensione dello schema propose/accept. Esso permette di staccare un token off-chain e di attaccarlo on-chain. Un token rappresenta un certo quantitativo di coin del bilancio. La struttura di un token è illustrata in Tabella \protect\hyperlink{struct_token}{2}.

\begin{longtable}[]{@{}ll@{}}
\caption{\protect\hypertarget{struct_token}{}{}Struttura di un token}\tabularnewline
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endfirsthead
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endhead
seq & Numero di sequenza del token\tabularnewline
value & Valore del token\tabularnewline
sign & Firma del token\tabularnewline
\bottomrule
\end{longtable}

Anche la struttura dati relativa a una propose viene estesa. I campi aggiunti sono illustrati in Tabella \protect\hyperlink{propose_estesa}{3}.

\begin{longtable}[]{@{}ll@{}}
\caption{\protect\hypertarget{propose_estesa}{}{}Campi propose aggiuntivi in un IPC}\tabularnewline
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endfirsthead
\toprule
Campo & Descrizione\tabularnewline
\midrule
\endhead
hash token & L'hash relativo al token\tabularnewline
type of propose & attach/detach\tabularnewline
\bottomrule
\end{longtable}

\textbf{\textbf{Precondizioni}} Alice e Berto hanno instaurato un IPC. Entrambi hanno un bilancio off-chain pari a 1 ETH.

\textbf{\textbf{Ritiro a caldo}} Alice vuole ritirare a caldo 0.5 ETH; effettua il detach off-chain di un token; invia a Berto una proposta contenente un token di 0.5 ETH che scala dal proprio bilancio. Berto risponde con proposta e token firmati. Il token firmato rappresenta la PoD (Proof of Detachment). Alice effettua l'attach in catena della PoD e ritira a caldo 0.5 ETH.

\textbf{\textbf{Ricarica a caldo}} Alice vuole ricaricare a caldo il canale di 0.5 ETH; effettua l'attach on-chain di un token depositando nello smart contract 0.5 ETH. Questa operazione on-chain viene notificata a Berto dallo smart contract; tale notifica rappresenta la PoA (Proof of Attachment). A questo punto Alice invia a Berto una proposta in cui effettua l'attach di un token di pari valore e incrementa di 0.5 ETH il proprio bilancio. Berto risponde con la proposta firmata, confermando la ricarica a caldo.

\textbf{\textbf{Double spending di un token}} Quando Alice ritira a caldo presentando un token, lo smart contract associa una PoA relativa al numero di sequenza del token corrente. Questo permette allo smart contract di non accettare token già spesi.

\hypertarget{fulgur-hub}{%
\section{Fulgur Hub}\label{fulgur-hub}}

\hypertarget{motivazioni}{%
\subsection{Motivazioni}\label{motivazioni}}

Sebbene i payment channel siano una svolta dal punto di vista della scalabilità della blockchain, essi rappresentano uno strumento ancora rudimentale e con un'esperienza utente limitata. Con gli inextinguishable payment channel vengono fatti dei miglioramenti dal punto di vista della UX; essi infatti grazie alle ricariche e i prelievi a caldo rendono dinamico il quantitativo di fondi bloccato in un payment channel, limitando al minimo le onerose operazioni di stabilimento del canale. Tuttavia rimane ancora impensabile dover inizializzare un canale di pagamento con ciascun individuo con cui si voglia instaurare un rapporto economico. A questo si preferisce un sistema che permetta di instaurare un singolo payment channel e che consenta di effettuare dei pagamenti con chiunque. Da questa necessità nasce Fulgur Hub {[}18{]}, ovvero migliorare l'esperienza utente degli IPC e potenziare alcune delle loro caratteristiche.

\hypertarget{caratteristiche}{%
\subsection{Caratteristiche}\label{caratteristiche}}

\textbf{\textbf{Transazioni istantanee ed economiche}} In Bitcoin la conferma di una transazione richiede 60 minuti. In un IPC basta lo scambio di due messaggi su protocollo http per effettuare e confermare un pagamento. Questo apre nuove prospettive economiche, ad esempio una macchina in cloud potrebbe essere pagata dopo ogni secondo di utilizzo o si potrebbe vedere il proprio stipendio accreditato dopo ogni minuto di lavoro effettuato; FulgurHub abilita questi casi d'uso.

\textbf{\textbf{Transazioni tra più di due entità}} In un IPC i pagamenti possono essere effettuati tra due partecipanti. FulgurHub consente di effettuare pagamenti tra gli N utenti registrati ad un FulgurHub.

\textbf{\textbf{Pagamenti ibridi}} FulgurHub permette di effettuare dei pagamenti ibridi. Ciascun utente infatti possiede due bilanci, uno on-chain e uno off-chain e può decidere di spostare dei fondi da uno stato off-chain a uno stato on-chain e viceversa. Inoltre abilita i pagamenti tra utenti di due FulgurHub diversi.

\textbf{\textbf{Autogestito}} In un IPC l'utente deve costantemente verificare e accettare la validità di un pagamento, oltre a contestare eventuali comportamentei scorretti della controparte. In FulgurHub i server degli utenti e dell'hub si occupano di gestire autonomamente diversi scenari, limitando allo stretto necessario l'intervento manuale.

\textbf{\textbf{Pagamenti trustless}} Caratteristica essenziale è che un utente onesto abbia la certezza di non perdere i propri fondi. In sistemi centralizzati questa garanzia esiste perché ci si fida di un'entità centrale, come una banca o un servizio di e-payment. In un FulgurHub questa garanzia è data dal protocollo stesso, in questo senso i pagamenti sono trustless.

\textbf{\textbf{Passività e anonimato}} FulgurHub è un sistema passivo; questo significa che l'hub non contatta mai gli utenti, ma solo quest'ultimi contattano l'hub. Questo permette agli utenti di non dover fornire il loro indirizzo ip reale e quindi di poter effettuare pagamenti anche dietro una rete come Tor.

\hypertarget{lavori-correlati}{%
\subsection{Lavori correlati}\label{lavori-correlati}}

\textbf{\textbf{Tumblebit}} Si tratta di un hub di pagamenti anonimo basato su Bitcoin. L'approccio di centralizzazione garantisce anonimato e pagamenti trustless. Sfortunatamente il particolare payment channel adottato è unidirezionale e ha un tempo di vita limitato {[}10{]}.

\textbf{\textbf{CoinBlesk}} Un bitcoin wallet che usa un server centrale che permette di eseguire dei pagamenti virtuali. Supporta micropagamenti istantanei, ma l'approccio non è considerabile trustless {[}3{]}.

\textbf{\textbf{Lightning e Raiden Network}} Entrambi i network si basano su un grafo di payment channel bidirezionali. Un pagamento avviene in maniera analoga all'instradamento di un pacchetto su internet. Una volta trovato il percorso ottimo esso deve essere completato con successo in ciascun hop intermedio. Se un solo hop fallisce il pagamento fallisce. Questo garantisce l'atomicità dei pagamenti {[}16{]} {[}15{]}. Sebbene Lightning Network e Raiden Network siano progettati per essere decentralizzati, la realtà economica fa tendere la topologia di rete alla centralizzazione; maggiore è il numero di hop, maggiori sono le commissioni e le probabilità di insuccesso. FulgurHub è stato disegnato con questo in mente e propone una topologia hub and spoke; un affondo su questa topologia viene fatto in Capitolo \ref{analisi}.

\hypertarget{analisi}{%
\chapter{Analisi}\label{analisi}}

Questo Capitolo descrive il processo di analisi svolto in questa tesi. In particolare in Sezione \ref{obiettivi} si discutono gli obiettivi dell'analisi. In Sezione \ref{descrizione-generale-dellarchitettura} si descrive l'architettura generale di FulgurHub. Infine in Sezione \ref{casi-duso} si descrivono i principali casi d'uso e la gestione di eventuali eccezioni.

\hypertarget{obiettivi}{%
\section{Obiettivi}\label{obiettivi}}

\hypertarget{dimostrazione-di-fattibilituxe0}{%
\subsection{Dimostrazione di fattibilità}\label{dimostrazione-di-fattibilituxe0}}

Un obiettivo di questa tesi è stato dimostrare la fattibilità delle principali feature di FulgurHub, progettando, implementando e verificando la correttezza delle caratteristiche principali di seguito esposte:

\textbf{\textbf{Apertura di un wallet}} In questo contesto aprire un wallet significa aprire un canale di pagamento con un FulgurHub. L'apertura di un canale di pagamento comporta un'operazione on-chain da parte dell'utente e consente di effettuare un numero potenzialmente illimitato di transazioni off-chain.

\textbf{\textbf{Pagamento X-Y}} Come detto in Capitolo \ref{background} ciascun utente di FulgurHub possiede due bilancio, uno on-chain e uno off-chain. FulgurHub consente il trasferimento di fondi da un tipo di bilancio all'altro. Con la formula pagamento X-Y, si intende un tipo di pagamento che sposta i fondi dal tipo di bilancio X (on-chain/off-chain) al tipo di bilancio Y (on-chain/off-chain). In particolare di seguito si elencano tutti i tipi di pagamento di cui questa tesi ha avuto l'obbiettivo di dimostrare la fattibilità:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Pagamento OffChain-OffChain}} Questo è il pagamento più conveniente in FulgurHub in quanto non necessità di nessuna onerosa operazione on-chain; in particolare questo pagamento sposta un certo quantitativo di coin dal bilancio off-chain del pagante al bilancio off-chain del pagato.
\item
  \textbf{\textbf{Pagamento OnChain-OnChain}} Riduce il bilancio on-chain del pagante e incrementa il bilancio on-chain del pagato; non differisce di molto da una classica operazione di pagamento sulla blockchain e infatti richiede un'operazione on-chain.
\item
  \textbf{\textbf{Pagamenti OffChain-OnChain}} Questo è il primo tipo di pagamento ibrido. Con pagamento ibrido si intende una transazione che sposta fondi da due tipi di depositi diversi; in particolare un pagamento OffChain-OnChain con un'operazione atomica riduce il deposito di stato off-chain del pagante e incrementa il deposito di stato on-chain del pagato.
\item
  \textbf{\textbf{Pagamenti OnChain-OffChain}} Altro pagamento di tipo ibrido; questa tipologia di pagamento sposta i fondi dal bilancio on-chain del pagante al bilancio off-chain del pagato.
\item
  \textbf{\textbf{Prelievi a caldo}} Questa feature viene ereditata dagli IPC e permette a un utente di un FulgurHub di effettuare un prelievo a caldo dei fondi off-chain senza chiudere il canale di pagamento.
\item
  \textbf{\textbf{Ricariche a caldo}} Anche questa operazione viene ereditata dagli IPC e consente a un utente di un FulgurHub di ricaricare il bilancio off-chain di un canale di pagamento già aperto.
\item
  \textbf{\textbf{Chiusura di un canale}} Un utente del FulgurHub può chiudere il canale di pagamento ritirando i fondi relativi al bilancio off-chain, al bilancio on-chain e eventuali pending token non utilizzati.
\end{itemize}

\hypertarget{dimostrare-la-scalabilituxe0-architetturale}{%
\subsection{Dimostrare la scalabilità architetturale}\label{dimostrare-la-scalabilituxe0-architetturale}}

Come detto in Capitolo \ref{background}, le motivazioni che hanno mosso la progettazione di FulgurHub riguardano i limiti architetturali di scalabilità della blockchain. Obiettivo di questa tesi è stato anche dimostrare la scalabilità architetturale di FulgurHub.

\hypertarget{descrizione-generale-dellarchitettura}{%
\section{Descrizione generale dell'architettura}\label{descrizione-generale-dellarchitettura}}

In FulgurHub ciascun utente possiede due bilancio, uno on-chain e uno off-chain. Effettuare un pagamento significa quindi aggiornare o il deposito di stato on-chain o il deposito di stato off-chain o entrambi nel caso dei pagamenti ibridi. Il deposito di stato on-chain è bloccato da uno smart contract. Mantenere le informazioni relative al deposito di stato off-chain è invece responsabilità dell'utente; a tale scopo l'utente utilizza un client che memorizza le informazioni necessarie su un database dedicato. In Figura \protect\hyperlink{architecture-hub-and-spoke}{4} si mostra la topologia hub-and-spoke in cui 4 utenti (Alice, Berto, Cecilia e Dario) operano su FulgurHub {[}18{]}.

\begin{figure}
\centering
\includegraphics[width=0.75\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/0cb1c91d1bf1109b259c180391b7bb08ad9e1da5.png}
\caption{\protect\hypertarget{architecture-hub-and-spoke}{}{}Architettura hub-and-spoke di FulgurHub}
\end{figure}

\textbf{\textbf{Hub}} L'hub è supportato da un modulo software che interagisce con lo smart contract. Il modulo è stateless, questo permette di replicarlo e di distribuire il carico su più macchine mediante un loadbalancer, favorendo disponibilità e scalabilità. L'hub è passivo, ovvero non contatta mai direttamente gli utenti; solo gli utenti possono contattare l'hub. La comunicazione da parte degli utenti verso l'hub avviene mediante una connessione http; a tale scopo l'hub mette a disposizione degli endpoint pubblici che permettono di effettuare tutte le principali operazioni, come ad esempio l'apertura di un wallet, le varie tipologie di pagamenti, la discussione di un aggiornamento errato o la chiusura del canale.

\textbf{\textbf{Client}} L'utente contatta l'hub per effettuare le operazioni di cui necessita. La comunicazione tra utente e hub viene mediata da un modulo software detto client. La relazione tra client e hub può essere descritta come una "registrazione trustless" del client al servizio di intermediazione offerto dall'hub {[}18{]}. Il client è supportato da un modulo software che interagisce con lo smart contract e l'hub. La registrazione dell'utente coincide con l'instaurazione di una particolare forma di inextinguishable payment channel tra utente e hub che permetta dei pagamenti ibridi, come descritto in \ref{casi-duso}. Un client può chiudere la registrazione dall'hub in ogni momento; in particolare deve chiudere la propria registrazione appena si verifica un comportamento anomalo da parte dell'hub.

\textbf{\textbf{Smart contract}} Lo smart contract ha varie responsabilità e rappresenta il punto di contatto tra gli utenti dell'hub e la blockchain. Il primo uso tangibile dello smart contract, lo si ha in fase di registrazione di un wallet; questo scenario d'uso applicativo infatti si fonda sull'apertura di un payment channel, che richiede come visto in Capitolo \ref{background} un'operazione on-chain, ovvero un'operazione che faccia uso dello smart contract. Inoltre lo smart contract viene utilizzato ogni qualvolta si debba effettuare un pagamento che abbia come punto di partenza o di arrivo il deposito di stato on-chain, in particolare i pagamenti: OnChain-OnChain, OnChain-OffChain e OffChain-OnChain. Altra responsabilità dello smart contract riguarda la ricarica e il ritiro di coin a caldo e la chiusura di un canale di pagamento. Infine esso supporta una relazione trustless tra i client e l'hub, ovvero permette l'uso dell'hub in assenza di fiducia reciproca. In particolare lo smart contract deve essere utilizzato ogni qualvolta una delle parti non si comporta correttamente.

\hypertarget{casi-duso}{%
\section{Casi d'uso}\label{casi-duso}}

\textbf{\textbf{Strutture dati e simbolismo}} FulgurHub si fonda su due tipi di strutture dati, le propose e i token. Una propose (\(\phi_i\)) descrive il balance off-chain di client (\(\beta^C_i\)) e hub (\(\beta^H_i\)). Le propose sono ordinate totalmente sulla base del numero di sequenza (\(i\)). Un token \(\tau_j\) può essere staccato (\(\mathbb{D}\)) o attaccato (\(\mathbb{A}\)) ad una propose. Inoltre una propose può essere firmata dal client (\(\phi^{\sigma_C}_i\)), dall'hub (\(\phi^{\sigma_H}_i\)) o da entrambi (\(\phi^{\sigma_C,\sigma_H}_i\)).

\begin{equation}
\label{Un esempio di propose}
\phi^{\sigma_C, \sigma_H}_i = <\beta^C_i, \beta^H_i, \tau_j ,\mathbb{D}||\mathbb{A}>
\end{equation}

Un token è identificato in maniera univoca dalla tupla \((j, \alpha_P)\), dove \(j\) identifica il numero di sequenza del token e \(\alpha_P\) l'indirizzo ethereum del pagato. Il client staccando un token può sottrarre una porzione \(\nu_j\) del proprio bilancio. Un token può essere staccato dal bilancio on-chain od off-chain. Un token può essere recapitato al pagato. Il pagato per riscuotere un token deve attaccarlo off-chain (mediante una propose) od on-chain (mediante lo smart contract). Esistono due tipi di token; quelli riscuotibili on-chain (\(\mathbb{ON}\)) e quelli riscuotibili off-chain (\(\mathbb{OFF}\)). Inoltre un token può essere firmato dal client (\(\tau^{\sigma_C}\)), dall'hub (\(\tau^{\sigma_H}\)) o da entrambi (\(\tau^{\sigma_C,\sigma_H}\)). Un token può essere riscosso entro un tempo di scadenza \(\exp\).

\begin{equation}
\label{Un esempio di token}
\tau^{\sigma_C,\sigma_H}_{y, ID(P)} = <\nu_y, exp, \mathbb{ON} || \mathbb{OFF}>
\end{equation}

Una propose \(\phi^{\sigma_C}_i\) con un token \(\tau_y\) detached (\(\mathbb{D}\)) firmato dal pagato rappresenta una ricevuta di pagamento. La ricevuta di pagamento è una prova incontrovertibile della riscossione di un token.

Per indicare il balance off-chain di un'entità \(k\) ad una propose con numero di sequenza pari a \(i\) si usa il simbolo \(\beta^k_i\), mentre per indicare il balance on-chain \(\overline{\beta^k}\).

L'indirizzo ethereum di un'entità \(k\) è indicato dal simbolo \(\alpha_k\). L'insieme di indirizzi ethereum che hanno una sottoscrizione attiva con il FulgurHub associato ad \(H\) è detto \(\Pi^H\).

\hypertarget{sottoscrizione-di-un-fulgurhub}{%
\subsection{Sottoscrizione di un FulgurHub}\label{sottoscrizione-di-un-fulgurhub}}

Alice vuole sottoscrivere una registrazione su un FulgurHub. Questa attività coincide con l'apertura di un payment channel.

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A\} \not\subset \Pi^H\)\\
b) L'hub ha deployato lo smart contract\\
c) Il server dell'hub è in ascolto

\textbf{\textbf{Descrizione delle interazioni}} Un client per sottoscrivere un FulgurHub deve eseguire la funzione subscribe dello smart contract fornendo il proprio indirizzo ethereum \(\alpha_C\), il bilancio iniziale off-chain \(\beta^C_0\) e on-chain \(\overline{\beta^C}\). Inoltre il client deve indicare il bilancio iniziale off-chain dell'hub \(\beta^H\). Una volta eseguita la transazioni on-chain viene recapitata una notifica all'hub \(<\beta^C_0, \overline{\beta^C}, \beta^H, \alpha_C>\). In Figura \protect\hyperlink{sottoscrizione-fulgur-hub}{5} viene fornito un diagramma di sequenza del caso d'uso.

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/04f0efaf37718c1595b116823ad81ba0c5cd42cf.png}
\caption{\protect\hypertarget{sottoscrizione-fulgur-hub}{}{}Sottoscrizione di un FulgurHub}
\end{figure}

\hypertarget{pagamento-onchain-onchain}{%
\subsection{Pagamento OnChain-OnChain}\label{pagamento-onchain-onchain}}

Un pagamento OnChain-OnChain sposta \(\nu\) fondi dal balance on-chain di Alice \(\overline{\beta^A}\) al balance on-chain di Berto \(\overline{\beta^B}\). Questo pagamento viene totalmente gestito dallo smart contract e non richiede alcuna interazione con i server dei client o dell'hub.

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A, \alpha^B\} \subseteq \Pi^H\)\\
b) Il balance on-chain di Alice e Berto è rispettivamente pari \(\overline{\beta^A}\) e \(\overline{\beta^B}\)

\textbf{\textbf{Descrizione delle interazioni}} Alice esegue il metodo transfer dello smart contract. L'esecuzione del metodo richiede il quantitativo \(\nu\) di fondi che si intende spostare e l'indirizzo ethereum \(\alpha^B\) di Berto. Terminata l'esecuzione del metodo lo smart contract aggiorna il balance on-chain di Alice in \(\overline{\beta^A}-\nu\) e quello di Berto in \(\overline{\beta^B}+\nu\). Un diagramma di sequenza è disponibile in Figura \protect\hyperlink{caso-duso-onchain-onchain}{6}.

\begin{figure}
\centering
\includegraphics[width=0.45\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/93641fac765513a2d2f82d9f2dfbec4180a4004a.png}
\caption{\protect\hypertarget{caso-duso-onchain-onchain}{}{}Pagamento OnChain-OnChain in FulgurHub.}
\end{figure}

\hypertarget{pagamento-offchain-offchain}{%
\subsection{Pagamento OffChain-OffChain}\label{pagamento-offchain-offchain}}

Un pagamento OffChain-OffChain sposta fondi dal balance off-chain di Alice \(\beta^A_i\) a quello di Berto \(\beta^B_i\). Questo tipo di pagamento non richiede interazioni con la catena, il che lo rende economico e istantaneo.

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A, \alpha^B\} \subseteq \Pi^H\)\\
b) Le ultime propose confermate nei canali di Alice e Berto sono \(\phi^A_i\) e \(\phi^B_j\).

\textbf{\textbf{Descrizione delle interazioni}} Alice costruisce, firma e invia \(\phi^{\sigma_A}_{i+1}\) all'hub. L'hub risponde con la propose \(\phi^{\sigma_A,\sigma_H}_{i+1}\) e il token \(\tau^{\sigma_A,\sigma_H}_{y, \alpha_B}\) controfirmati.

\begin{equation}
\begin{aligned}
\label{Propose detach pagamento OffChain-OffChain}
\tau^{\sigma_A}_{y, \alpha_B} =  <\nu_y, exp, \mathbb{OFF}>\\
\phi^{\sigma_A}_{i+1} = <\beta^A_i-\nu_y, \beta^H_i, \tau^{\sigma_A}_{y, \alpha_B} ,\mathbb{D}>
\end{aligned}
\end{equation}

\(\tau^{\sigma_A,\sigma_H}_{y, \alpha_B}\) rappresenta una PoD (Proof of Detachment). Alice invia la PoD a Berto. Berto costruisce \(\phi^{\sigma_B}_{j+1}\) effettuando l'attach della PoD.

\begin{equation}
\label{Propose attach pagamento OffChain-OffChain}
\phi^{\sigma_B}_{j+1} = <\beta^B_i+\nu_y, \beta^H_i-\nu_y, \tau^{\sigma_A}_{y, \alpha_B} ,\mathbb{A}>
\end{equation}

Berto invia la ricevuta di pagamento \(\phi^{\sigma_B}_{j+1}\) ad Alice. Alice ora ha in mano una prova incontrovertibile del fatto che il suo token sia stato riscosso. In questa fase l'hub si è esposto di \(\nu_i\) fondi sul canale di Berto; Alice deve ribilanciare questa situazione e lo fa costruendo \(\phi^{\sigma_A}_{i+2}\), una nuova propose in cui attacca la PoD ricevuta da Berto.

\begin{equation}
\label{Propose attach pagamento OffChain-OffChain}
\phi^{\sigma_A}_{i+2} = <\beta^B_i+\nu_y, \beta^H_i-\nu_y, \tau^{\sigma_B}_y ,\mathbb{A}>_(\sigma_B)
\end{equation}

Il pagamento OffChain-OffChain è considerato concluso. In Figura \protect\hyperlink{caso-duso-offchain-offchain}{7} viene fornito uno diagramma di sequenza delle interazioni.

\begin{figure}
\centering
\includegraphics[width=0.65\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/b1bde96f20d21fca489e9d87e0b8870dad29ee84.png}
\caption{\protect\hypertarget{caso-duso-offchain-offchain}{}{}Pagamento OffChain-OffChain in FulgurHub.}
\end{figure}

\textbf{\textbf{B non invia la ricevuta di pagamento ad A}} Il collegamento tra Alice e Berto è opzionale. Alice infatti può contattare l'hub e richiedere la ricevuta di pagamento.

\textbf{\textbf{L'hub non permette di staccare un token}} Se l'hub non è collaborativo, Alice chiude il canale.

\textbf{\textbf{L'hub non permette di attaccare un token}} Se l'hub non è collaborativo, Berto ha la facoltà di chiudere il canale e successivamente riscuotere il pending token on-chain.

\textbf{\textbf{Mancanza di cooperazione nel ricevere un pagamento}} Il client può cancellare il pagamento al termine della sua scadenza, ritirandolo off-chain.

\hypertarget{pagamento-offchain-onchain}{%
\subsection{Pagamento OffChain-OnChain}\label{pagamento-offchain-onchain}}

Un pagamento OffChain-OnChain consiste nel spostare fondi dal balance off-chain di Alice \(\beta^A_i\) al balance on-chain dxi Berto \(\overline{\beta^B}\).

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A, \alpha^B\} \subseteq \Pi^H\)\\
b) L'ultima propose confermata nel canale di Alice è \(\phi^A_i\).

\textbf{\textbf{Descrizione delle interazioni}} Alice costruisce, firma e invia \(\phi^{\sigma_A}_{i+1}\) all'hub. L'hub risponde con la propose \(\phi^{\sigma_A,\sigma_H}_{i+1}\) e il token \(\tau^{\sigma_A,\sigma_H}_{y, \alpha_B}\) controfirmati.

\begin{equation}
\begin{aligned}
\label{Propose detach pagamento OffChain-OnChain}
\tau^{\sigma_A}_{y, \alpha_B} =  <\nu_y, exp, \mathbb{ON}> \\
\phi^{\sigma_A}_{i+1} = <\beta^A_i-\nu_y, \beta^H_i, \tau^{\sigma_A}_{y, \alpha_B} ,\mathbb{D}>_(\sigma_A)
\end{aligned}
\end{equation}

\(\tau^{\sigma_A,\sigma_H}_{y, \alpha_B}\) rappresenta una PoD (Proof of Detachment). Alice invia la PoD a Berto. Berto effettua l'attach on-chain del token mediante la funzione attach dello smart contract. Lo smart contract aggiorna il balance on-chain di Berto in \(\overline{\beta^B}+\nu_y\). Il pagamento è considerato concluso. In Figura \protect\hyperlink{caso-duso-offchain-onchain}{8} viene fornito uno diagramma di sequenza delle interazioni.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/9e2c82452902c5d65499f954bdea128a9a780c15.png}
\caption{\protect\hypertarget{caso-duso-offchain-onchain}{}{}Pagamento OffChain-OnChain in FulgurHub.}
\end{figure}

\hypertarget{pagamento-onchain-offchain}{%
\subsection{Pagamento OnChain-OffChain}\label{pagamento-onchain-offchain}}

Un pagamento OnChain-OffChain consiste nel spostare fondi dal balance on-chain di Alice \(\overline{\beta^A}\) al balance off-chain di Berto \(\beta^B_j\).

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A, \alpha^B\} \subseteq \Pi^H\)\\
b) L'ultima propose confermata nel canale di Berto è \(\phi^B_j\)\\
c) Il balance on-chain di Alice è \(\overline{\beta_A}\)

\textbf{\textbf{Descrizione delle interazioni}} Alice esegue la funzione detach dello smart contract fornendo l'indirizzo di Berto (\(\alpha_B\)) e il quantitativo \(\nu\) che si vuole staccare. Lo smart contract aggiorna il balance on-chain di Alice in \(\overline{\beta_A}+\nu\). Terminata l'esecuzione della funzione, lo smart contract invia la relativa PoD a Berto. Berto costruisce, firma e invia \(\phi^{\sigma_B}_{j+1}\) all'hub, attaccando la PoD. L'hub risponde con la propose firmata \(\phi^{\sigma_B,\sigma_H}_{j+1}\). In Figura \protect\hyperlink{caso-duso-onchain-offchain}{9} viene fornito uno diagramma di sequenza delle interazioni.

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/7c5cecbfc23dcd6d389d9b4b8cb29e41e735d248.png}
\caption{\protect\hypertarget{caso-duso-onchain-offchain}{}{}Pagamento OnChain-OffChain in FulgurHub.}
\end{figure}

\begin{equation}
\begin{aligned}
\label{Propose detach pagamento OnChain-OffChain}
\tau^{\sigma_B}_y =  <\nu_y, \bot, \mathbb{ON}> \\
\phi^{\sigma_B}_{j+1} = <\beta^B_j-\nu_y, \beta^H_j, \tau^{\sigma_B}_{y, \alpha_B} ,\mathbb{A}>
\end{aligned}
\end{equation}

\hypertarget{prelievo-a-caldo}{%
\subsection{Prelievo a caldo}\label{prelievo-a-caldo}}

Effettuare un prelievo a caldo significa spostare dei fondi dal balance off-chain di Alice \(\beta^A_i\) al balance on-chain di Alice \(\overline{\beta^A}\).

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A\} \subseteq \Pi^H\)\\
b) L'ultima propose confermata nel canale di Alice è \(\phi^A_i\)\\
c) Il balance on-chain di Alice è \(\overline{\beta_A}\)

\textbf{\textbf{Descrizione delle interazioni}} Alice costruisce, firma e invia \(\phi^{\sigma_A}_{i+1}\) all'hub. L'hub risponde con la propose \(\phi^{\sigma_A,\sigma_H}_{i+1}\) e il token \(\tau^{\sigma_A,\sigma_H}_{y, \alpha_A}\) controfirmati.

\begin{equation}
\begin{aligned}
\label{Propose detach pagamento OffChain-OffChain}
\tau^{\sigma_A}_{y, \alpha_B} =  <\nu_y, exp, \mathbb{OFF}>\\
\phi^{\sigma_A}_{i+1} = <\beta^A_i-\nu_y, \beta^H_i, \tau^{\sigma_A}_{y, \alpha_A} ,\mathbb{D}>
\end{aligned}
\end{equation}

Alice presenta \(\tau^{\sigma_A,\sigma_H}_{y, \alpha_A}\) in catena eseguendo la funzione attach dello smart contract. Lo smart contract aggiorna il balance on-chain di Alice in \(\overline{\beta_A}+\nu\). Un diagramma delle interazioni viene fornito in Figura \protect\hyperlink{caso-duso-prelievo-a-caldo}{10}.

\begin{figure}
\centering
\includegraphics[width=0.5\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/2c75d626f2bc6f6659b1983142761c3a0942b652.png}
\caption{\protect\hypertarget{caso-duso-prelievo-a-caldo}{}{}Prelievo a caldo in FulgurHub.}
\end{figure}

\hypertarget{ricarica-a-caldo}{%
\subsection{Ricarica a caldo}\label{ricarica-a-caldo}}

Effettuare una ricarica a caldo significa spostare \(\nu\) fondi dal balance on-chain di Alice \(\overline{\beta^A}\) a quello off-chain \(\beta^A_i\).

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A\} \subseteq \Pi^H\)\\
b) L'ultima propose confermata nel canale di Alice è \(\phi^A_i\)\\
c) Il balance on-chain di Alice è \(\overline{\beta_A}\)

\textbf{\textbf{Descrizione delle interazioni}} Alice esegue la funzione detach dello smart contract passando come parametri \(\alpha_A\) e \(\nu\). Lo smart contract aggiorna il balance on-chain di Alice in \(\overline{\beta^A}+\nu\). Una volta terminata l'esecuzione della funzione, lo smart contract invia all'hub e ad Alice la relativa PoD. Alice costruisce, firma e invia \(\phi^{\sigma_A}_{i+1}\) all'hub. L'hub risponde con la propose \(\phi^{\sigma_A,\sigma_H}_{i+1}\) e il token \(\tau^{\sigma_A,\sigma_H}_{y, \alpha_A}\) controfirmati. Un diagramma del protocollo viene fornito in Figura \protect\hyperlink{caso-duso-ricarica-a-caldo}{11}.

\begin{equation}
\begin{aligned}
\label{Propose detach pagamento OffChain-OffChain}
\tau^{\sigma_A}_{y, \alpha_B} =  <\nu_y, \bot, \mathbb{OFF}>\\
\phi^{\sigma_A}_{i+1} = <\beta^A_i+\nu_y, \beta^H_i, \tau^{\sigma_A}_{y, \alpha_A} ,\mathbb{A}>_(\sigma_A)
\end{aligned}
\end{equation}

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/4ce29426cb79fc7088d861a1870840f9609f96cd.png}
\caption{\protect\hypertarget{caso-duso-ricarica-a-caldo}{}{}Ricarica a caldo in FulgurHub.}
\end{figure}

\hypertarget{chiusura-di-un-canale}{%
\subsection{Chiusura di un canale}\label{chiusura-di-un-canale}}

\textbf{\textbf{Precondizioni}}\\
a) \(\{\alpha^A\} \subseteq \Pi^H\)\\
b) L'ultima propose confermata nel canale di Alice è \(\phi^A_i\)

\textbf{\textbf{Descrizione delle interazioni}} Alice porta in catena l'ultima propose \(\phi^A_i\) con la funzione close dello smart contract. Lo smart contract registra la richiesta di chiusura del canale e avvia un timer di durata pari a una costante \(G\) dello smart contract, detta grace period. Scaduto il timer, Alice può ritirare tutti i suoi fondi \(\overline{\beta^A}+\beta^A_{i}\) eseguendo la funzione withdraw dello smart contract.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/7e6401394881180ad5acd92a648697ce2d00b155.png}
\caption{\protect\hypertarget{caso-duso-chiusura-canale}{}{}Chiusura canale in FulgurHub.}
\end{figure}

\hypertarget{riscossione-di-un-pending-token}{%
\subsection{Riscossione di un pending token}\label{riscossione-di-un-pending-token}}

Un client può riscuotere dei pending token, ovvero dei token non ancora scaduti o utilizzati, durante il grace period.

\textbf{\textbf{Precondizioni}}\\
a) Alice ha avviato la chiusura del canale.\\
b) Il timer \(G\) non è ancora scaduto.

\textbf{\textbf{Descrizione delle interazioni}} Alice presenta in catena un pending token utilizzando la funzione redeemToken dello smart contract. L'esecuzione di questa funzione non corrisponde con il prelievo immediato del token. Una notifica della presentazione del token corrente viene inviata all'hub. Una volta scaduto \(G\), Alice può riscuotere il suo balance (incrementato del quantitativo del token).

\textbf{\textbf{Tentativo di ritirare un pending token già usato}} Alice presenta in catena un pending token già riscosso. Durante il grace period l'hub può portare in catena la relativa PoD del token utilizzando la funzione argueRedemptionToken. Alice viene punita per il suo comportamento malevolo; tutti i suoi fondi (on-chain e off-chain) vengono trasferiti all'hub.

\hypertarget{progettazione-e-sviluppo}{%
\chapter{Progettazione e sviluppo}\label{progettazione-e-sviluppo}}

Questo Capitolo descrive responsabilità, requisiti, motivazioni tecnologiche e dettagli implementativi di FulgurHub. In particolare in Sezione \ref{smart-contract} si descrivono le funzionalità dello smart contract e la sua interfaccia, in Sezione \ref{client} si descrive il client e in Sezione \ref{hub} si descrive l'hub.

\hypertarget{smart-contract}{%
\section{Smart contract}\label{smart-contract}}

\hypertarget{requisiti-e-responsabilituxe0}{%
\subsection{Requisiti e responsabilità}\label{requisiti-e-responsabilituxe0}}

Lo smart contract è il punto di contatto tra lo stato off-chain e quello on-chain di FulgurHub. Esso deve permettere la gestione delle informazioni on-chain necessarie mediante una mappa del tipo \(ID(utente) \rightarrow Wallet\). \(ID(utente)\) è un identificativo univoco dell'utente (E.G. il suo indirizzo pubblico) e \(Wallet\) è una struttura dati; di seguito vengono illustrati tutti i campi di questa struttura dati:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Balance on-chain}} Si tratta di un intero senza segno che rappresenta il bilancio dell'utente registrato sulla blockchain. Questo bilancio varia ogni volta che viene effettuata un pagamento da o verso la catena. In particolare i pagamenti che modificano il valore di questo campo sono i pagamenti OnChain-OnChain, i pagamenti OnChain-OffChain e pagamenti OffChain-OnChain.
\item
  \textbf{\textbf{PoDs}} Questo campo rappresenta una lista di prove di avvenuto distacco di un token da parte dell'utente associato al wallet corrente. Quando un token viene staccato in catena, esso viene memorizzato all'interno di questa lista. Ciascun utente ha la propria lista di token staccati. In questo modo non è possibile staccare più volte lo stesso token.
\item
  \textbf{\textbf{PoAs}} Un token oltre ad essere staccato può essere attaccato che equivale al concetto di spesa di un token. Anche in questo caso è presente una lista per ciascun utente, denominata \(PoAs\) (proofs of attachment). Questa lista contiene tutti i token che sono stati attaccati dall'utente. Memorizzare la lista di proof of attachment consente di evitare il problema della doppia spesa di un token. Ogni qualvolta un utente dell'hub tenta di attaccare un token, lo smart contract verifica che esso non sia contenuto all'interno di questa lista; nel caso in cui il token sia già presente viene sollevata un'eccezione e l'operazione non viene portata a termine.
\item
  \textbf{\textbf{Latest propose}} La chiusura del canale avviene in due fasi, la richiesta di chiusura e la finalizzazione della chiusura con il relativo sblocco dei fondi. La richiesta di chiusura viene effettuata da uno degli utenti dell'hub che decide di voler chiudere il proprio wallet. Essa avviene mediante l'esecuzione di un'operazione on-chain in cui viene portata in catena l'ultima propose concordata tra utente e hub. Questa propose presentata in chiusura viene memorizzata nel campo latest propose. La memorizzazione di questo campo on-chain è necessaria per permettere alla controparte di discutere la proposta nel caso in cui non fosse realmente l'ultima concordata (vedi Capitolo \ref{analisi}).
\item
  \textbf{\textbf{Timestamp chiusura}} Quando viene richiesta la chiusura del canale, oltre all'ultima propose viene memorizzato un timestamp. Questo campo è necessario in quanto l'operazione di finalizzazione può essere eseguita solo quando è trascorso un periodo di tempo pari al grace period. Lo smart contract confronta il timestamp attuale con quello di chiusura per verificare che sia trascorso il tempo necessario.
\end{itemize}

Un utente dell'hub che vuole interagire con il suo stato on-chain può farlo eseguendo una delle operazioni messe a disposizione. Queste operazioni riguardano l'iscrizione all'hub, i pagamenti ibridi, la chiusura di un wallet e la riscossione di pending token. Oltre a questo lo smart contract mette a disposizione degli eventi. Gli eventi sono dei messaggi che possono essere pubblicati nel momento in cui una qualche funzionalità viene eseguita. Questi eventi sono pubblici e chiunque può mettercisi in ascolto. Di seguito gli eventi messi a disposizione:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Subscribed}} Un utente per registrarsi a un FulgurHub non deve contattare direttamente l'hub. L'unica operazione richiesta dall'utente è l'esecuzione dell'operazione di registrazione del relativo smart contract. Quando l'utente esegue questa operazione on-chain, un evento denominato \(Subscribed\) deve essere sollevato dallo smart contract; questo evento descrive le caratteristiche del Wallet registrato: l'identificativo dell'utente, i bilanci off-chain iniziali di utente e hub e il bilancio on-chain iniziale dell'utente. Per considerare una registrazione conclusa, l'hub deve prendere coscienza di essa, memorizzando le informazioni relative al wallet sul proprio database locale; a tale scopo l'hub si registra all'evento \(Subscribed\).
\item
  \textbf{\textbf{TokenDetached}} Quando si effettua un prelievo a caldo utente e hub concordano il distacco di un token mediante lo scambio di messaggi off-chain. Terminata questa operazione l'utente presenta in catena il token effettuando il distacco. In questo contesto lo smart contract deve rilasciare un evento denominato \(TokenDetached\). L'hub si registra a questo evento; registrandosi a questo evento prende coscienza del fatto che un token che ha firmato è stato effettivamente distaccato.
\item
  \textbf{\textbf{TokenAttached}} Quando un token viene attaccato in catena, l'evento \(TokenAttached\) deve essere sollevato. Questo evento permette all'hub di prendere coscienza dell'avvenuta spesa di un token da parte dell'utente.
\item
  \textbf{\textbf{WalletClosed}} La richiesta di chiusura di un canale con l'esecuzione della relativa operazione on-chain deve coincidere con il rilascio dell'evento \(WalletClosed\). Questo evento permette all'hub di prendere coscienza dell'avvenuta richiesta di chiusura del canale, permettendogli di discutere la proposta presentata nel caso in cui non fosse valida.
\end{itemize}

\hypertarget{motivazioni-tecnologiche}{%
\subsection{Motivazioni tecnologiche}\label{motivazioni-tecnologiche}}

La blockchain presa come riferimento è Ethereum. Le motivazioni che hanno mosso la scelta di questa blockchain rispetto ad altre riguardano il supporto di smart contract e l'ambiente di sviluppo maturo. In particolare è stato utilizzato Solidity per lo sviluppo dello smart contract, ganache come blockchain di test locale e web3 come interfaccia JavaScript per interagire con la blockchain di Ethereum.

\textbf{\textbf{Linguaggio di programmazione dello smart contract}} Solidity è il linguaggio di programmazione C-like turing completo con il quale è possibile sviluppare gli smart contract in FulgurHub. Esso mette a disposizione un compilatore e un debugger. Il compilatore trasforma il linguaggio in codice macchina compatibile con la EVM (Ethereum Virtual Machine). Il debugger di Solidity permette di conoscere lo stato intermedio di uno smart contract durante la sua esecuzione.

\textbf{\textbf{Rete blockchain di test}} Ganache è una blockchain di test locale, che semplifica la fase di test di uno smart contract; permette di deployare ed eseguire uno smart contract, senza utilizzare la rete principale di Ethereum, abbattendo costi e tempi di sviluppo.

\textbf{\textbf{Interfaccia smart contract}} Web3 è un'interfaccia in JavaScript che permette di eseguire le operazioni più comuni sulla blockchain di Ethereum (E.G. il deployment di uno smart contract, l'esecuzione di una funzione o un pagamento). Le interazioni con lo smart contract non avvengono direttamente con web3, ma sono wrappate da un'interfaccia di più alto livello. Sì è deciso di utilizzare questa interfaccia per non legare il particolare tipo di blockchain adottata con l'implementazione in se. Sebbene infatti la scelta progettuale sia ricaduta su Ethereum, questo approccio consente di estendere le funzionalità implementate su diverse tipologie di blockchain. Il linguaggio di programmazione adottato per implementare l'interfaccia di livello più alto è TypeScript; è stato utilizzato TypeScript rispetto a JavaScript dato il supporto della tipizzazione forte. Questo ha permesso di definire interfacce stabili e di intercettare eventuali bug già in fase di compilazione.

\textbf{\textbf{Altre soluzioni tecnologiche}} Esistono altre interessanti soluzioni alternative a Ethereum. Una in particolare è Tezos. Tezos come Ethereum mette a disposizione la possibilità di deployare smart contract con un linguaggio di programmazione turing-completo. Il linguaggio di riferimento è Michelson, un subset di Ocaml che semplifica la verifica formale di correttezza di uno smart contract. Sebbene Tezos non sia stato utilizzato in fase di sviluppo, un suo futuro impiego potrebbe essere facilmente integrabile grazie alla definizione dell'interfaccia di alto livello dello smart contract.

\hypertarget{dettagli-implementativi}{%
\subsection{Dettagli implementativi}\label{dettagli-implementativi}}

\textbf{\textbf{Interfaccia in TypeScript}} Di seguito viene esposta l'interfaccia di alto livello dello smart contract in TypeScript. Il funzionamento delle singole operazioni è descritto in dettaglio nel Capitolo \ref{analisi}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{interface}\NormalTok{ SmartContract }\OperatorTok{\{}
    \AttributeTok{subscribe}\NormalTok{(}\DataTypeTok{wallet}\OperatorTok{:}\NormalTok{ Wallet)}\OperatorTok{;}
    \AttributeTok{detachToken}\NormalTok{(}\DataTypeTok{token}\OperatorTok{:}\NormalTok{ Token)}\OperatorTok{;}
    \AttributeTok{attachToken}\NormalTok{(}\DataTypeTok{token}\OperatorTok{:}\NormalTok{ Token)}\OperatorTok{;}
    \AttributeTok{transfer}\NormalTok{(}\DataTypeTok{payeeAddress}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,} \DataTypeTok{amount}\OperatorTok{:}\NormalTok{ BigNumber)}\OperatorTok{;}
    \AttributeTok{close}\NormalTok{(}\DataTypeTok{propose}\OperatorTok{:}\NormalTok{ Propose)}\OperatorTok{;}
    \AttributeTok{redeemToken}\NormalTok{(}\DataTypeTok{token}\OperatorTok{:}\NormalTok{ Token)}\OperatorTok{;}
    \AttributeTok{argueRedemptionToken}\NormalTok{(}\DataTypeTok{token}\OperatorTok{:}\NormalTok{ Token)}\OperatorTok{;}
    \AttributeTok{withdraw}\NormalTok{()}\OperatorTok{;}
    \AttributeTok{argueClosure}\NormalTok{(}\DataTypeTok{propose}\OperatorTok{:}\NormalTok{ Propose)}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Il tipo Wallet}} Il tipo Wallet rappresenta la registrazione di un utente su FulgurHub. Esso contiene l'indirizzo pubblico del client e dello smart contract, il bilancio on-chain/off-chain iniziale del client e il bilancio off-chain dell'hub.

\textbf{\textbf{Il tipo Propose}} Il tipo Propose autocontiene tutte le informazioni che descrivono una proposta: il nonce, l'indirizzo pubblico dell'utente, l'indirizzo dello smart contract, il bilancio off-chain corrente del client e dell'hub, il relativo token che si è deciso di attaccare o staccare e la firma della propose.

\textbf{\textbf{Il tipo Token}} Rappresenta un token. In particolare contiene: nonce, indirizzo dello smart contract, indirizzo pubblico del pagato, il quantitativo spostato, il tipo di catena dove può essere attaccato (off-chain o on-chain), la data di scadenza e la relativa firma.

\hypertarget{client}{%
\section{Client}\label{client}}

\hypertarget{responsabilituxe0-e-requisiti}{%
\subsection{Responsabilità e requisiti}\label{responsabilituxe0-e-requisiti}}

Il client è il modulo che permette a un utente di interagire con l'hub, gli altri client e lo smart contract; deve rimanere attivo per il tempo di vita del canale di pagamento instaurato con l'hub. Le sue responsabilità riguardano: esecuzione di comandi privati/pubblici, gestione di eventi asincroni e registrazione dei messaggi off-chain scambiati.

\textbf{\textbf{Comandi privati/pubblici}} Un comando privato può essere eseguito solamente dall'utente associato al canale di pagamento. Questi comandi permettono di registrarsi all'hub, effettuare dei pagamenti, chiudere un canale e riscuotere pending token. Un comando pubblico è accessibile a qualunque utente associato a un certo FulgurHub; questi permettono di ricevere pagamenti off-chain e ricevute di pagamento.

\textbf{\textbf{Messaggi asincroni}} Lo smart contract genera delle notifiche; le notifiche sono dei messaggi asincroni. Il client deve poter ricevere e gestire questi messaggi asincroni. Queste notifiche riguardano il detach di un token on-chain e la ricezione di una proof of detachment.

\textbf{\textbf{Registrazione messaggi off-chain}} Tutti i messaggi scambiati off-chain devono poter essere memorizzati in maniera permanente dal client.

\hypertarget{motivazioni-tecnologiche-1}{%
\subsection{Motivazioni tecnologiche}\label{motivazioni-tecnologiche-1}}

\textbf{\textbf{RPC privata / endpoint pubblici}} L'RPC privata e gli endpoint pubblici permettono di eseguire rispettivamente i comandi privati e pubblici. Entrambi sono stati implementati con un server http Node.js; questo ha permesso di utilizzare TypeScript, mantenendo un unico linguaggio di programmazione per il backend. L'RPC è esposta su una porta privata (\(10101\)), mentre i comandi che devono esserre accessibili a tutti sono esposti su una porta pubblica (\(80\)).

\textbf{\textbf{Il monitor}} L'architettura FulgurHub deve gestire un gran numero di eventi asincroni; solo la corretta gestione degli utenti permette di ottenere una corretta e sicura costruzione di FulgurHub. Data la cruciale importanza della loro gestione, si è deciso di localizzare questa responsabilità in un modulo dedicato denominato monitor. Il monitor gestisce due eventi asincroni: \(onChainDetachment\) e \(onProofOfDetachmentPushed\).

\begin{itemize}
\tightlist
\item
  \(onChainDetachment\) è un evento generato dallo smart contract quando qualcuno effettua il detach di un token on-chain a favore dell'utente corrente.
\item
  \(onProofOfDetachmentPushed\) è un evento generato quando l'utente corrente riceve una nuova proof of detachment.
\end{itemize}

Il comportamento legato a un evento non è contenuto all'interno del monitor; il monitor infatti permette solo di agganciare o sganciare a un evento un certo insieme di comportamenti, ovvero di funzioni. Questo approccio consente di estendere facilmente le funzionalità del modulo e quindi migliora la modificabilità del progetto.

\textbf{\textbf{Il database}} La registrazione dei messaggi off-chain è stata delegata a un database. Priorità assoluta di questo database è che non rappresenti un collo di bottiglia per il throughput dei pagamenti. La scelta è ricaduta su LevelDB, un database chiave-valore embedded, single process, multi thread basato sulle API linux POSIX. Le motivazioni che supportano questa scelta riguardano le ottime performance in scrittura di LevelDB {[}9{]}.

\hypertarget{dettagli-implementativi-1}{%
\subsection{Dettagli implementativi}\label{dettagli-implementativi-1}}

Di seguito sono descritti i principali endpoint privati suddivisi per categoria di operazione.

\textbf{\textbf{Iscrizione di un wallet}} Un utente può registrare un wallet su FulgurHub mediante questo endpoint. Il tipo \(Wallet\) contiene tutte le informazioni necessarie e viene passato come unico parametro http:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/subscribe}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \DataTypeTok{wallet}\OperatorTok{:}\NormalTok{ Wallet}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Pagamento OnChain-OnChain}} Come visto in Capitolo \ref{analisi} i pagamenti OnChain-OnChain vengono gestiti dallo smart contract. Questo endpoint privato avvia il trasferimento eseguendo l'operazione \(transfer\) dello smart contract:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/transferOnChainOnChain}
\end{Highlighting}
\end{Shaded}

I parametri necessari a eseguire questa operazione sono \(recipientAddress\), ovvero l'indirizzo del pagato e \(amount\) ovvero l'importo che si vuole trasferire.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{recipientAddress}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{amount}\OperatorTok{:}\NormalTok{ BigNumber}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Pagamento OffChain-OffChain}} La prima fase di un pagamento OffChain-OffChain consiste nell'effettuare il detach di un token OffChain-OffChain, ovvero di un token che è stato staccato off-chain e che verrà attaccato off-chain. I parametri necessari a eseguire il detach sono \(addressPayee\), ovvero l'indirizzo pubblico del pagato, \(uriPayee\) l'indirizzo del server del pagato, \(amount\) il quantitativo che si intende trasferire e \(ttl\) il tempo di vita del token:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/detachOffChainTokenOffChain}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{addressPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{uriPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{amount}\OperatorTok{:}\NormalTok{ BigNumber}\OperatorTok{,}
    \DataTypeTok{ttl}\OperatorTok{:}\NormalTok{ BigNumber}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Una volta ricevuta la proof of detachment dall'hub, essa può essere inviata al client mediante questo endpoint:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/sendProofOfDetachment}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{proofOfDetachment}\OperatorTok{:}\NormalTok{ Token}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Il pagato recupera le proof of detachment ricevute mediante questo endpoint:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/popProofOfDetachment}
\end{Highlighting}
\end{Shaded}

e invia al client pagante la ricevuta di pagamento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/sendPaymentReceipt}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{paymentReceipt}\OperatorTok{:}\NormalTok{ PaymentReceipt}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Questo endpoint permette al pagante di una transazione OffChain-OffChain di ribilanciare il canale. Con questo comando una transazione OffChain-OffChain viene considerata conclusa:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/settleOffChainOffChainTransfer}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{propose}\OperatorTok{:}\NormalTok{ Propose}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Pagamento OnChain-OffChain}} Avvia un pagamento OnChain-OffChain. I parametri necessari sono gli stessi dell'endpoint \(/detachOffChainTokenOffChain\):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/detachOnChainTokenOffChain}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{addressPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{uriPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{amount}\OperatorTok{:}\NormalTok{ BigNumber}\OperatorTok{,}
    \DataTypeTok{ttl}\OperatorTok{:}\NormalTok{ BigNumber}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Pagamento OffChain-OnChain}} Avvia un pagamento di tipo OffChain-OnChain:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/detachOffChainTokenOnChain}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{addressPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{uriPayee}\OperatorTok{:}\NormalTok{ string}\OperatorTok{,}
    \DataTypeTok{amount}\OperatorTok{:}\NormalTok{ BigNumber}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Incassare un token}} Una volta ricevuto un off-chain token, questo può essere riscosso mediante questo endpoint:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/attachTokenOffChain}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{proofOfDetachment}\OperatorTok{:}\NormalTok{ Token}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Incassare un pending token}} Un pending token può essere incassato durante il grace period del canale mediante questo endpoint:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/redeemToken}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{token}\OperatorTok{:}\NormalTok{ Token}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/retrievePaymentReceipt}
\end{Highlighting}
\end{Shaded}

Nel caso in cui il pagato non sia collaborativo un utente può richiedere una ricevuta di pagamento all'hub utilizzando questo endpoint:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{clientAddress}\OperatorTok{:}\NormalTok{ string}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Chiudere un canale}} Avvia la chiusura del canale di pagamento. La chiusura avviene presentando in catena \(latestPropose\), ovvero l'ultima propose concordata tra client e hub:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/close}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{latestPropose}\OperatorTok{:}\NormalTok{ Propose}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Finalizzare chiusura}} Terminato il grace period, il client può effettuare il \(withdraw\), finalizzando la chiusura del canale. Questo endpoint permette di eseguire questa operazione:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/withdraw}
\end{Highlighting}
\end{Shaded}

\hypertarget{hub}{%
\section{Hub}\label{hub}}

\hypertarget{responsabilituxe0-e-requisiti-1}{%
\subsection{Responsabilità e requisiti}\label{responsabilituxe0-e-requisiti-1}}

Chiunque abbia abbastanza fondi on-chain può inizializzare un FulgurHub. Per fare questo occorre deployare il relativo smart contract e mantenere costantemente attivo il modulo descritto in questa Sezione. L'hub è un modulo software molto simile al client. Le sue responsabilità riguardano:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Esecuzione di comandi pubblici}} Gli utenti devono poter contattare l'hub eseguendo dei comandi pubblici.
\item
  \textbf{\textbf{Gestione di eventi asincroni}} L'hub deve poter gestire degli eventi asincroni. Nell specifico le notifiche generate dallo smart contract.
\item
  \textbf{\textbf{Registrazione messaggi off-chain}} Tutti i messaggi off-chain scambiati con gli utenti dell'hub devono poter essere memorizzati; essi infatti rappresentano delle prove di avvenuto pagamento che potrebbero dover essere presentate nel futuro in catena.
\end{itemize}

I principali requisiti architetturali dell'hub sono i seguenti:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Performance}} L'hub deve eseguire le singole operazioni velocemente; questo è essenziale specialmente nel caso in cui occorra gestire frequenti micropagamenti.
\item
  \textbf{\textbf{Scalabilità}} L'hub deve poter scalare orizzontalmente; questo significa che per far fronte a un crescente numero di transazione basterà aggiungere dei nodi di calcolo.
\item
  \textbf{\textbf{Modificabilità}} La base di codice deve poter essere facilmente modificabile ed estensibile. In particolare non ci si vuole legare fortemente alle tecnologie adottate.
\end{itemize}

\hypertarget{motivazioni-tecnologiche-2}{%
\subsection{Motivazioni tecnologiche}\label{motivazioni-tecnologiche-2}}

\textbf{\textbf{Gli endpoint pubblici}} L'hub è un modulo passivo; questo significa che non contatta mai deliberatamente un utente, ma è quest'ultimo che passivamente riceve dei comandi dall'hub. Questi comandi vengono impartiti mediante degli endpoint http pubblici. Come nel client, il server http è stato implementato mediante Node.js; questo ha permesso di mantenere TypeScript come unico linguaggio di backend.

\textbf{\textbf{Il monitor}} Come nel client anche nell'hub la gestione degli eventi asincroni è delegata a un modulo denominato monitor. Il modulo permette di agganciare a un evento un certo comportamento, senza cambiare il contenuto del monitor stesso. L'aggiunta o la rimozione degli eventi è rara, mentre invece la modifica del comportamento legato a un evento può cambiare frequentemente. Questo facilita l'estensione della gestione degli eventi, migliorando la modificabilità dell'architettura.

\textbf{\textbf{Database}} Come descritto in Capitolo \ref{analisi} l'hub riceve messaggi firmati dai client che deve memorizzare. Per la natura del protocollo di FulgurHub questi messaggi vengono frequentemente memorizzati e raramente letti. Il numero delle scritture può essere anche ingente. Per questo motivo si è deciso di utilizzare un database chiave valore, in particolare Redis, dato il suo considerevole throughput in scrittura {[}17{]}. Altro motivo per cui è stato adottato Redis rispetto a un altro database chiave-valore è rappresentato dalla possibilità di effettuare tuning delle sue qualità architetturali. In particolare il teorema CAP dice che un'architettura può avere solo due tra queste caratteristiche contemporaneamente:

\begin{itemize}
\tightlist
\item
  Consistenza
\item
  Disponibilità
\item
  Partizionamento
\end{itemize}

Redis permette di scegliere quali di queste due caratteristiche avere. In una prima fase di un FulgurHub ha senso scegliere solamente la consistenza e la disponibilità. Sebbene un requisito essenziale dell'architettura sia la scalabilità, una singola istanza Redis su commodity hardware garantisce un throughput ampiamente sufficiente {[}17{]}.

Nel caso in cui si debba aumentare il numero di transazioni al secondo si potrà scegliere tra scalare verticalmente l'hardware o abilitare lo sharding a sfavore della disponibilità.

\hypertarget{dettagli-implementativi-2}{%
\subsection{Dettagli implementativi}\label{dettagli-implementativi-2}}

Di seguito vengono descritti gli unici endpoint pubblici che mette a disposizione l'hub.

\textbf{\textbf{Ricezione di una propose}} Come visto in Capitolo \ref{analisi} il client effettua dei pagamenti proponendo l'aggiornamento del bilancio off-chain all'hub. Questa proposta viene servita dal client mediante il seguente endpoint pubblico messo a disposizione dall'hub. L'hub a sua volta verifica la proposta, aggiorna lo stato off-chain del canale di pagamento scrivendolo sul database in locale e invia la proposta controfirmata al client.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/sendPropose}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \DataTypeTok{clientSignedPropose}\OperatorTok{:}\NormalTok{ Propose}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Richiesta di ricevuta di pagamento}} Un client per essere certo che un pagamento OffChain-OffChain sia andato a buon fine necessita di una ricevuta di pagamento. Quando il pagato è completamente collaborativo è lui stesso a fornire questa ricevuta di pagamento al pagante. Quando in un pagamento OffChain-OffChain il pagato non è collaborativo è l'hub a dover fornire la ricevuta di pagamento. Come già detto precedentemente l'hub però è passivo, il che significa che non può contattare direttamente il client. Per questo motivo il seguente endpoint viene messo a disposizione. Il client infatti interrogando questo endpoint e fornendo il proprio indirizzo pubblico ottiene la corrispettiva ricevuta di pagamento.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/retrievePaymentReceipt}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
  \DataTypeTok{clientAddress}\OperatorTok{:}\NormalTok{ string}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{prove-sperimentali}{%
\chapter{Prove sperimentali}\label{prove-sperimentali}}

Questo Capitolo discute le prove sperimentali condotte sull'implementazione di FulgurHub. In particolare in Sezione \ref{gli-obiettivi} si discutono gli obiettivi, in Sezione \ref{lapproccio-adottato} l'approccio adottato, in Sezione \ref{throughput-del-client} si mostrano i risultati relativi al client, in Sezione \ref{throughput-dellhub} si discutono i risultati dell'hub, in Sezione \ref{profiling} viene descritto il profiling dell'operazione di pagamento OffChain-OffChain e infine in Sezione \ref{considerazioni} si fanno delle considerazioni generali sui risultati ottenuti in termini di performance e scalabilità.

\hypertarget{gli-obiettivi}{%
\section{Gli obiettivi}\label{gli-obiettivi}}

\textbf{\textbf{Verifica performance}} Un obiettivo delle prove sperimentali è stato verificare le performance dell'architettura; in particolare l'analisi del throughput di client e server relativamente ai pagamenti OffChain-OffChain. Sebbene siano state implementate anche altre tipologie di pagamento (OffChain-OnChain, OnChain-OffChain e OnChain-OnChain) si è preferito non effettuare prove di performance di tutte le operazioni che interagiscono con la catena. Il throughput delle operazioni che interagiscono con la catena sarebbe limitato superiormente dal throughput della blockchain di riferimento. In questo contesto con throughput si intende il numero di transazioni completate in un secondo.

\textbf{\textbf{Profiling}} Altro obiettivo delle prove sperimentali è stato il profiling dei pagamenti OffChain-OffChain; come visto in Capitolo \ref{analisi}, un pagamento OffChain-OffChain è costituito da un insieme di sotto task; la durata di ciascun sotto task è stata profilata, con l'intento di trovare eventuali colli di bottiglia e di capire quale sia la distribuzione delle operazioni nel tempo.

\hypertarget{lapproccio-adottato}{%
\section{L'approccio adottato}\label{lapproccio-adottato}}

\textbf{\textbf{Benchmark server}} Eseguire un test delle performance di FulgurHub richiede il setup di un ambiente complesso e distribuito. In particolare ciascun client e hub dovrebbe risiede su un nodo di calcolo dedicato. A tale scopo è stato realizzato un benchmark server. Il benchmark server permette di automatizzare il setup dell'ambiente di test e di eseguire dei performance test parametrizzati. L'esecuzione delle operazioni avviene mediante chiamate http. Di seguito si descrivono i comandi messi a disposizione dal server.

Questo endpoint permette di effettuare il setup dell'ambiente di test, in particolare vengono deployati i seguenti servizi:

\begin{itemize}
\tightlist
\item
  \textbf{\textbf{Redis}} Un'istanza di Redis viene deployata. Essa rappresenta il database dell'hub.
\item
  \textbf{\textbf{Hub}} Con hub si intende il server dell'hub. Anch'esso viene deployato su un nodo dedicato.
\item
  \textbf{\textbf{Client}} Ciascun client viene deployato su un nodo dedicato. Il numero di client da deployare viene specificato mediante il parametro \(numberOfClients\).
\item
  \textbf{\textbf{Ganache}} Una blockchain di test deve essere deployata per supportare le operazioni on-chain necessarie come la sottoscrizione dell'hub. A tale scopo è stato utilizzato ganache.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/environment}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{numberOfClients}\OperatorTok{:}\NormalTok{ Number}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Per cancellare l'ambiente di test un comando dedicato viene messo a disposizione:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{DELETE}\OperatorTok{:} \SpecialStringTok{/environment}
\end{Highlighting}
\end{Shaded}

Mediante il seguente comando è possibile eseguire un benchmark relativo ai pagamenti OffChain-OffChain; è possibile specificare due parametri: \(concurrent\) e \(requests\). \(concurrent\) indica il numero di coppie di utenti che devono scambiare dei pagamenti in maniera concorrente. \(requests\) indica quanti pagamenti deve eseguire ciascuna coppia di utenti.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POST}\OperatorTok{:} \SpecialStringTok{/benchmark/transfer/offchain/offchain}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{\{}
    \DataTypeTok{concurrent}\OperatorTok{:}\NormalTok{ Number}\OperatorTok{,}
    \DataTypeTok{requests}\OperatorTok{:}\NormalTok{ Number}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{\textbf{Docker}} Ciascun nodo dell'ambiente di test è stato deployato su un container LXC. In particolare il benchmark server utilizza le API di Docker, per costruire e distruggere i container di cui necessita. L'uso di nodi virtualizzati rispetto a nodi fisici reali ha vari vantaggi: tra cui l'abbattimento dei costi e dei tempi di sviluppo e la possibilità di aumentare o diminuire le risorse hardware dedicate di ciascun container modificandone la configurazione. D'altra parte la virtualizzazione non permette di tenere conto della latenza di rete.

\textbf{\textbf{Simulazione della latenza di rete}} Come detto nel precedente paragrafo, la virtualizzazione non permette di tenere conto della latenza di rete. Per questo motivo in fase di test è stata simulata ritardando di un fattore delta le comunicazioni remote.

\hypertarget{throughput-del-client}{%
\section{Throughput del client}\label{throughput-del-client}}

Con throughput del client si intende il numero di pagamenti al secondo confermati che un singolo utente può effettuare. Esso è stato verificato sia al variare della RAM che della latenza. Il client è realizzato in Node.js, questo significa che viene eseguito un unico processo senza alcun thread di supporto; per questo motivo non sono state effettuate delle prove sperimentali al variare del numero di core a disposizione.

\textbf{\textbf{Al variare della RAM}} Questo test è stato effettuato variando il quantitativo di RAM assegnato ai nodi del client e senza variare quella dedicata all'hub. Come è possibile verificare dai dati in tabella e dal grafico in Figura \protect\hyperlink{client-ram-chart}{13} il client raggiunge il throughput massimo con un 1 o 2 GB di RAM.

\begin{longtable}[]{@{}lll@{}}
\caption{\protect\hypertarget{client-ram-table}{}{}Throughput client al variare della RAM.}\tabularnewline
\toprule
N° & RAM & Throughput (tx/s)\tabularnewline
\midrule
\endfirsthead
\toprule
N° & RAM & Throughput (tx/s)\tabularnewline
\midrule
\endhead
1 & 500MB & 13\tabularnewline
2 & 1GB & 32\tabularnewline
3 & 2GB & 41\tabularnewline
\bottomrule
\end{longtable}

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/ce12ed804396416f8559f9995b56aa55e8fde5e5.png}
\caption{\protect\hypertarget{client-ram-chart}{}{}Throughput client al variare della RAM}
\end{figure}

\textbf{\textbf{Al variare della latenza}} I test sulla latenza sono stati eseguiti fissando la RAM di tutti i nodi a 2GB e simulando un ritardo tra tutte le connessioni remote instaurate. Come è possibile notare in Figura \protect\hyperlink{client-latenza-chart}{14} la latenza incide in maniera direttamente proporzionale sul throughput del client.

\begin{longtable}[]{@{}lll@{}}
\caption{\protect\hypertarget{client-latenza-table}{}{}Throughput client al variare della latenza.}\tabularnewline
\toprule
N° & Ritardo simulato (s) & Throughput (tx/s)\tabularnewline
\midrule
\endfirsthead
\toprule
N° & Ritardo simulato (s) & Throughput (tx/s)\tabularnewline
\midrule
\endhead
1 & 0 & 43\tabularnewline
2 & 0.5 & 22\tabularnewline
3 & 1 & 13.5\tabularnewline
4 & 2 & 7\tabularnewline
5 & 10 & 1.4\tabularnewline
\bottomrule
\end{longtable}

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/c7f0557eef2212632d339bc24b02ee6841eda854.png}
\caption{\protect\hypertarget{client-latenza-chart}{}{}Barchart throughput client al variare della latenza.}
\end{figure}

\hypertarget{throughput-dellhub}{%
\section{Throughput dell'hub}\label{throughput-dellhub}}

Con throughput dell'hub si intende il numero di pagamenti concorrenti al secondo confermati che un singolo hub può gestire. Esso è stato verificato sia al variare della RAM che della latenza. Anche l'hub come il client è realizzato in Node.js, questo significa che viene eseguito un unico processo senza alcun thread di supporto; per questo motivo non sono state effettuate delle prove sperimentali al variare del numero di core a disposizione.

\textbf{\textbf{Al variare della RAM}} Il test è stato effettuato variando il quantitativo di RAM assegnata all'hub. Come è possibile verificare dal grafico in Figura \protect\hyperlink{hub-ram-chart}{15} l'hub raggiunge il throughput massimo con un 1 o 2 GB di RAM. In particolare su un nodo di calcolo con 500MB di RAM il numero di transazioni completate al secondo è pari a 45. Aumentando la RAM a 1GB il throughput quasi raddoppia, raggiungendo 84 transazioni al secondo.

\begin{longtable}[]{@{}lll@{}}
\caption{\protect\hypertarget{hub-ram-table}{}{}Throughput hub al variare della RAM.}\tabularnewline
\toprule
N° & RAM & Throughput (tx/s)\tabularnewline
\midrule
\endfirsthead
\toprule
N° & RAM & Throughput (tx/s)\tabularnewline
\midrule
\endhead
1 & 500MB & 45\tabularnewline
2 & 1GB & 84\tabularnewline
3 & 2GB & 84\tabularnewline
\bottomrule
\end{longtable}

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/064de6fe09898f6ad82d2d022964dd905b4467b5.png}
\caption{\protect\hypertarget{hub-ram-chart}{}{}Barchart throughput hub al variare della RAM}
\end{figure}

\textbf{\textbf{Al variare della latenza}} I test sulla latenza relativi all'hub sono stati effettuati fissando a 2GB la RAM di tutti i nodi e simulando un ritardo tra tutte le connessioni remote instaurate. Come è possibile notare in Figura \protect\hyperlink{hub-latenza-chart}{16}, la latenza incide in maniera direttamente proporzionale sul throughput del client.

\begin{longtable}[]{@{}lll@{}}
\caption{\protect\hypertarget{hub-latenza-table}{}{}Throughput hub al variare della latenza.}\tabularnewline
\toprule
N° & Latenza (s) & Throughput (tx/s)\tabularnewline
\midrule
\endfirsthead
\toprule
N° & Latenza (s) & Throughput (tx/s)\tabularnewline
\midrule
\endhead
1 & 0 & 84\tabularnewline
2 & 0.5 & 43\tabularnewline
3 & 1 & 21\tabularnewline
4 & 2 & 13\tabularnewline
5 & 10 & 2\tabularnewline
\bottomrule
\end{longtable}

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/76c94dd237f4a05f34cf12ec96f546675475c55d.png}
\caption{\protect\hypertarget{hub-latenza-chart}{}{}Barchart throughput hub al variare della latenza.}
\end{figure}

\hypertarget{profiling}{%
\section{Profiling}\label{profiling}}

Come visto nel Capitolo \ref{analisi} un pagamento OffChain-OffChain per essere considerato concluso richiede lo scambio di un certo quantitativo di messaggi, vedi Figura \protect\hyperlink{profiling-messaggi-offchain}{17}. In Sezione \ref{throughput-del-client} si è visto che su una macchina con 2GB di RAM un client riesce a completare fino a 41 pagamenti al secondo; quindi un pagamento viene completato in circa 24ms.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/da9d9d42a9b1c714cfc80d99a4c10c39bdefa46b.png}
\caption{\protect\hypertarget{profiling-messaggi-offchain}{}{}Pagamento OffChain-OffChain in FulgurHub.}
\end{figure}

Rispetto alle operazioni indicate in Figura \protect\hyperlink{profiling-messaggi-offchain}{17}, la loro distribuzione nel tempo è indicata nel diagramma in Figura \protect\hyperlink{profiling-offchain}{18}.

\begin{figure}
\centering
\includegraphics[width=1\textwidth,height=\textheight]{./tex2pdf.-9e1a7949cf63fbfb/1c952f5a6c3a9dd15b2dda711ea25d0215f5779b.png}
\caption{\protect\hypertarget{profiling-offchain}{}{}Profiling pagamento OffChain-OffChain}
\end{figure}

Come è possibile notare dalla Figura \protect\hyperlink{profiling-offchain}{18} le operazioni più onerose risultano essere il detach del token, l'attach del token e l'invio della propose di settlement, ovvero tutte le operazioni che richiedono la firma di un messaggio. Questo risultato è quello aspettato, infatti la firma crittografica richiede un lavoro computazionale maggiore rispetto alla lettura e invio di un messaggio. Node.js dal punto di vista dell'ottimizzazione di operazioni computazionali onerose non è la tecnologia adatta, data la sua natura single thread; per questo motivo la firma dei messaggi è delegata a un modulo software dedicato e ottimizzato scritto in C basato sulle N-API di Node.js.

\hypertarget{considerazioni}{%
\section{Considerazioni}\label{considerazioni}}

Sulla base dei dati presentati nelle precedenti sezioni, si discutono i risultati in termini di performance e di scalabilità.

\textbf{\textbf{Performance}} Su un singolo nodo con hardware adeguato, l'implementazione di FulgurHub presentata in questa tesi può arrivare a gestire fino a 84 transazioni al secondo. In Tabella \protect\hyperlink{fulgurhub_confronto}{8} si confronta il throughput di FulgurHub con quello delle principali blockchain. Come è possibile notare FulgurHub permette di ottenere un throughput 5 volte maggiore rispetto a quello della blockchain sottostante (Ethereum) e di decuplicare quello relativo all'attuale implementazione di BitCoin.

\begin{longtable}[]{@{}lll@{}}
\caption{\protect\hypertarget{fulgurhub_confronto}{}{}Throughput FulgurHub a confronto con le principali blockchain.}\tabularnewline
\toprule
N° & Tecnologia & Throughput (tx/s)\tabularnewline
\midrule
\endfirsthead
\toprule
N° & Tecnologia & Throughput (tx/s)\tabularnewline
\midrule
\endhead
1 & BitCoin & 7\tabularnewline
2 & Ethereum & 15\tabularnewline
3 & FulgurHub & 84\tabularnewline
\bottomrule
\end{longtable}

\textbf{\textbf{Scalabilità dell'hub}} Un singolo nodo di FulgurHub permette di ottenere un throughput sensibilmente maggiore rispetto a quello delle principali blockchain. Oltre a questo l'hub è un modulo stateless, ovvero il singolo nodo hardware non ha uno stato; lo stato dell'hub infatti è memorizzato su un database dedicato (Redis); questa caratteristica permette di replicarlo senza particolari difficoltà. Con una configurazione adeguata, basata su un load balancer che distribuisca le richieste su più istanze, il numero di transazioni gestite dall'hub può scalare linearmente, in maniera direttamente proporzionale al numero di nodi.

\hypertarget{conclusioni-e-sviluppi-futuri}{%
\chapter{Conclusioni e sviluppi futuri}\label{conclusioni-e-sviluppi-futuri}}

\hypertarget{risultati-ottenuti}{%
\section{Risultati ottenuti}\label{risultati-ottenuti}}

Durante il periodo di lavoro di questa tesi è stata completata l'implementazione di un FulgurHub. Questa implementazione ha un throughput di transazioni completate sensibilmente maggiore rispetto alle principali blockchain e inoltre data la sua natura stateless risulta essere facilmente distribuibile su più nodi di calcolo, favorendone la scalabilità orizzontale.

\hypertarget{sviluppi-futuri}{%
\section{Sviluppi futuri}\label{sviluppi-futuri}}

\hypertarget{autogestione-finanziaria}{%
\subsection{Autogestione finanziaria}\label{autogestione-finanziaria}}

L'apertura di un canale di pagamento comporta l'inizializzazione di un balance off-chain iniziale di client e hub. Client e hub concordano in fase di inizializzazione un rapporto tra questi due bilanci che deve essere mantenuto costante. In particolare un rapporto particolarmente alto potrebbe essere indicato per un utente che effettua un frequente numero di pagamenti; un venditore invece potrebbe avere maggiore interesse a concordare un rapporto più basso. Quando viene effettuato un pagamento ibrido, il bilancio off-chain dell'hub sul canale del pagante viene ridotto, comportandone un inevitabile sbilanciamento. Di fondamentale importanza risulta essere dunque l'autogestione finanziaria dell'hub. In particolare l'hub deve costantemente monitorare il balance di tutti i canali di pagamento e ricaricare quelli che risultano essere sbilanciati. Come visto in Capitolo \ref{background} per costruzione un IPC permette di effettuare una ricarica a caldo; l'autogestione finanziaria avviene sulla base del meccanismo di ricarica a caldo di un IPC.

\hypertarget{scambio-di-token-diversi}{%
\subsection{Scambio di token diversi}\label{scambio-di-token-diversi}}

L'attuale implementazione di FulgurHub permette lo scambio di token dello stesso tipo. In particolare i pagamenti descritti in Capitolo \ref{analisi} riguardano solamente lo scambio della cryptomoneta relativa alla blockchain sottostante l'implementazione; nel caso in specifico Ethereum e quindi ETH. I token scambiati in FulgurHub possono però rappresentare anche altri concetti. Un'interessante prospettiva futura rappresenta la possibilità di consentire lo scambio mediante un FulgurHub di token di diversa natura. Questo consentirà lo swap atomico di concetti diversi.

\newpage

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-bentov2016cryptocurrencies}{}%
{[}1{]} Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. 2016. Cryptocurrencies without proof of work. In \emph{International conference on financial cryptography and data security}, 142--157.

\leavevmode\hypertarget{ref-BlockchainStats:online}{}%
{[}2{]} blockchain.com. Average number of transactions per block.

\leavevmode\hypertarget{ref-bocek2017coinblesk}{}%
{[}3{]} Thomas Bocek, Sina Rafati, Bruno Rodrigues, and Burkhard Stiller. 2017. Coinblesk--a real-time, bitcoin-based payment approach and app. \emph{Blockchain Engineering} (2017), 14.

\leavevmode\hypertarget{ref-TheBitco9:online}{}%
{[}4{]} Maria Bustillos. 2013. The bitcoin boom.

\leavevmode\hypertarget{ref-AProofof65:online}{}%
{[}5{]} Vitalik Buterin. 2016. A proof of stake design philosophy.

\leavevmode\hypertarget{ref-buterin2014next}{}%
{[}6{]} Vitalik Buterin and others. 2014. A next-generation smart contract and decentralized application platform. \emph{white paper} (2014).

\leavevmode\hypertarget{ref-StateCha92:online}{}%
{[}7{]} Jeff Coleman. 2015. State channels, an explanation.

\leavevmode\hypertarget{ref-gervais2016security}{}%
{[}8{]} Arthur Gervais, Ghassan O Karame, Karl Wüst, Vasileios Glykantzis, Hubert Ritzdorf, and Srdjan Capkun. 2016. On the security and performance of proof of work blockchains. In \emph{Proceedings of the 2016 acm sigsac conference on computer and communications security}, 3--16.

\leavevmode\hypertarget{ref-googlele43:online}{}%
{[}9{]} Google. LevelDB is a fast key-value storage library written at google that provides an ordered mapping from string keys to string values.

\leavevmode\hypertarget{ref-heilman2017tumblebit}{}%
{[}10{]} Ethan Heilman, Leen Alshenibr, Foteini Baldimtsi, Alessandra Scafuro, and Sharon Goldberg. 2017. TumbleBit: An untrusted bitcoin-compatible anonymous payment hub. In \emph{Network and distributed system security symposium}.

\leavevmode\hypertarget{ref-king2012ppcoin}{}%
{[}11{]} Sunny King and Scott Nadal. 2012. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake. \emph{self-published paper, August} 19, (2012).

\leavevmode\hypertarget{ref-kwon2014tendermint}{}%
{[}12{]} Jae Kwon. 2014. Tendermint: Consensus without mining. \emph{Draft v. 0.6, fall} (2014).

\leavevmode\hypertarget{ref-luu2016secure}{}%
{[}13{]} Loi Luu, Viswesh Narayanan, Chaodong Zheng, Kunal Baweja, Seth Gilbert, and Prateek Saxena. 2016. A secure sharding protocol for open blockchains. In \emph{Proceedings of the 2016 acm sigsac conference on computer and communications security}, 17--30.

\leavevmode\hypertarget{ref-nakamoto2008bitcoin}{}%
{[}14{]} Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. (2008).

\leavevmode\hypertarget{ref-raiden101:online}{}%
{[}15{]} Raiden Network. 2017. What is the raiden network?

\leavevmode\hypertarget{ref-poon2016bitcoin}{}%
{[}16{]} Joseph Poon and Thaddeus Dryja. 2016. The bitcoin lightning network: Scalable off-chain instant payments. \emph{draft version 0.5} 9, (2016), 14.

\leavevmode\hypertarget{ref-Howfasti99:online}{}%
{[}17{]} Redis. 2015. How fast is redis?

\leavevmode\hypertarget{ref-Spini2018}{}%
{[}18{]} Federico Spini. 2018. State channels for blockchain scalability: Capabilities, limitations, perspectives. PhD dissertation, Engineering Department of Rome Tre University.

\leavevmode\hypertarget{ref-VISA2015:online}{}%
{[}19{]} Visa. 2015. Visa inc. Is a global payments technology company that connects consumers, businesses, financial institutions and governments in more than 200 countries and territories, enabling them to use electronic payments instead of cash and checks.

\end{document}